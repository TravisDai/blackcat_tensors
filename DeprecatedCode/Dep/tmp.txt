
//
////Matrix Vec mul
//	template<class U, int rows, class LD, class voider = std::enable_if<MTF::same<evaluation_type, derived&>::conditional>>
//	auto operator *(const vec<U, rows, math_library, LD>& param) const {
//
//		return typename
//		MTF::IF_ELSE<Identity::RANK == 2,
//				vec<
//					binary_expression_dotproduct<
//							scalar_type, functor_type, typename MTF::determine_functor<U>::type, math_library,
//							derived::COMPILE_TIME_ROWS(), derived::COMPILE_TIME_ROWS(), 1,  //dims
//							derived::COMPILE_TIME_ROWS(), rows, derived::COMPILE_TIME_LD_ROWS(),
//							derived::transposed(), false>,
//					derived::COMPILE_TIME_ROWS(), math_library, typename default_OS<math_library, derived::COMPILE_TIME_ROWS()>::type>,
//				void
//		>::type(this->data(), param.data());
//	}
//
//	//mat mat
//	template<class U, int rows, int cols, class LD>
//	auto operator *(const mat<U, rows, cols, math_library, LD>& param) const {
//		return typename
//		MTF::IF_ELSE<Identity::RANK == 2,
//				mat<
//					binary_expression_dotproduct<
//							scalar_type, functor_type, typename MTF::determine_functor<U>::type, math_library,
//							derived::COMPILE_TIME_ROWS(), derived::COMPILE_TIME_ROWS(), cols,  //dims
//							derived::COMPILE_TIME_ROWS(), rows, derived::COMPILE_TIME_LD_ROWS(),
//							derived::transposed(), false>,
//					derived::COMPILE_TIME_ROWS(), cols, math_library, typename default_OS<math_library, derived::COMPILE_TIME_ROWS(), cols>::type>,
//				void
//		>::type(this->data(), param.data());
//	}
//
//	//Mat by RowVec OR Vec by RowVec
//	template<class U, int cols, class LD>
//	auto operator *(const rowVec<U, cols, math_library, LD>& param) const {
//		return typename
//		MTF::IF_ELSE<true,
//				mat<
//					binary_expression_dotproduct<
//							scalar_type, functor_type, typename MTF::determine_functor<U>::type, math_library,	//Eval,type, left functor_Type, right functor_type,
//							derived::COMPILE_TIME_ROWS(), derived::COMPILE_TIME_ROWS(), cols,   //MNK
//							derived::COMPILE_TIME_ROWS(), cols, derived::COMPILE_TIME_LD_ROWS(), //LD
//							derived::transposed(), false>,
//					derived::COMPILE_TIME_ROWS(), cols, math_library, typename default_OS<math_library, derived::COMPILE_TIME_ROWS(), cols>::type>,
//				void
//		>::type(this->data(), param.data());
//	}
//
//	template<class U>
//	typename scalar_impl<U*>::add_expression operator +(const Scalar<U, math_library>& param) const {
//		return typename scalar_impl<U*>::add_expression(asBase().expression_packet(), this->data(), param.data());
//	}
//	template<class U>
//	typename scalar_impl<U*>::sub_expression operator -(const Scalar<U, math_library>& param) const {
//		return typename scalar_impl<U*>::sub_expression(asBase().expression_packet(), this->data(), param.data());
//	}
//	template<class U>
//	typename scalar_impl<U*>::div_expression operator /(const Scalar<U, math_library>& param) const {
//		return typename scalar_impl<U*>::div_expression(asBase().expression_packet(), this->data(), param.data());
//	}
//	template<class U>
//	typename scalar_impl<U*>::mul_expression operator %(const Scalar<U, math_library>& param) const {
//		return typename scalar_impl<U*>::mul_expression(asBase().expression_packet(), this->data(), param.data());
//	}
//
//	template<class U>
//	derived& operator +=(const Scalar<U, math_library>& param) {
//		asBase() = typename scalar_impl<U*>::add_expression(asBase().expression_packet(), this->data(), param.data());
//		return asBase();
//	}
//	template<class U>
//	derived& operator -=(const Scalar<U, math_library>& param) {
//		asBase() = typename scalar_impl<U*>::sub_expression(asBase().expression_packet(), this->data(), param.data());
//		return asBase();
//	}
//	template<class U>
//	derived& operator /=(const Scalar<U, math_library>& param) {
//		asBase() = typename scalar_impl<U*>::div_expression(asBase().expression_packet(), this->data(), param.data());
//		return asBase();
//	}
//	template<class U>
//	derived& operator %=(const Scalar<U, math_library>& param) {
//		asBase() = typename scalar_impl<U*>::mul_expression(asBase().expression_packet(), this->data(), param.data());
//		return asBase();
//	}
//
//	template<class U>
//	struct scalar_impl {
//			using add_expression = typename std::conditional<derived::RANK() == 0,
//				typename MTF::expression_substitution<binary_expression_scalar_LR<scalar_type, add, functor_type, U>, derived>::type,
//				typename MTF::expression_substitution<binary_expression_scalar_L<scalar_type, add, functor_type, U>, derived>::type>::type;
//
//		using sub_expression = typename std::conditional<derived::RANK() == 0,
//				typename MTF::expression_substitution<binary_expression_scalar_LR<scalar_type, sub, functor_type, U>, derived>::type,
//				typename MTF::expression_substitution<binary_expression_scalar_L<scalar_type, sub, functor_type, U>, derived>::type>::type;
//
//
//		using div_expression = typename std::conditional<derived::RANK() == 0,
//				typename MTF::expression_substitution<binary_expression_scalar_LR<scalar_type, div, functor_type, U>, derived>::type,
//				typename MTF::expression_substitution<binary_expression_scalar_L<scalar_type, div, functor_type, U>, derived>::type>::type;
//
//		using mul_expression = typename std::conditional<derived::RANK() == 0,
//				typename MTF::expression_substitution<binary_expression_scalar_LR<scalar_type, mul, functor_type, U>, derived>::type,
//				typename MTF::expression_substitution<binary_expression_scalar_L<scalar_type, mul, functor_type, U>, derived>::type>::type;
//
//	};


//
//		using sub_expression =
//				typename MTF::IF_ELSE<derived::RANK() != SCALAR && param_deriv::RANK() != SCALAR, //Neither are scalar
//						typename MTF::expression_substitution<binary_expression<scalar_type, sub, functor_type, param_functor_type>, derived>::type,
//						typename MTF::IF_ELSE<derived::RANK() == SCALAR && param_deriv::RANK() == SCALAR,
//							typename MTF::expression_substitution<binary_expression_scalar_LR<scalar_type, sub, functor_type, param_functor_type>, derived>::type,
//								typename MTF::IF_ELSE<derived::RANK() == SCALAR,
//									typename MTF::expression_substitution<binary_expression_scalar_L<scalar_type, sub, functor_type, param_functor_type>, derived    >::type,
//									typename MTF::expression_substitution<binary_expression_scalar_R<scalar_type, sub, functor_type, param_functor_type>, param_deriv>::type
//							>::type
//						>::type
//				>::type;
//
//		using div_expression =
//				typename MTF::IF_ELSE<derived::RANK() != SCALAR && param_deriv::RANK() != SCALAR, //Neither are scalar
//						typename MTF::expression_substitution<binary_expression<scalar_type, div, functor_type, param_functor_type>, derived>::type,
//						typename MTF::IF_ELSE<derived::RANK() == SCALAR && param_deriv::RANK() == SCALAR,
//							typename MTF::expression_substitution<binary_expression_scalar_LR<scalar_type, div, functor_type, param_functor_type>, derived>::type,
//								typename MTF::IF_ELSE<derived::RANK() == SCALAR,
//									typename MTF::expression_substitution<binary_expression_scalar_L<scalar_type, div, functor_type, param_functor_type>, derived    >::type,
//									typename MTF::expression_substitution<binary_expression_scalar_R<scalar_type, div, functor_type, param_functor_type>, param_deriv>::type
//							>::type
//						>::type
//				>::type;
//
//		using mul_expression =
//						typename MTF::IF_ELSE<derived::RANK() != SCALAR && param_deriv::RANK() != SCALAR, //Neither are scalar
//								typename MTF::expression_substitution<binary_expression<scalar_type, mul, functor_type, param_functor_type>, derived>::type,
//								typename MTF::IF_ELSE<derived::RANK() == SCALAR && param_deriv::RANK() == SCALAR,
//									typename MTF::expression_substitution<binary_expression_scalar_LR<scalar_type, mul, functor_type, param_functor_type>, derived>::type,
//										typename MTF::IF_ELSE<derived::RANK() == SCALAR,
//											typename MTF::expression_substitution<binary_expression_scalar_L<scalar_type, mul, functor_type, param_functor_type>, derived    >::type,
//											typename MTF::expression_substitution<binary_expression_scalar_R<scalar_type, mul, functor_type, param_functor_type>, param_deriv>::type
//									>::type
//								>::type
//						>::type;

//	template<class param_deriv, class param_traits, class functor>
//	struct custom_impl {
//		static constexpr int SCALAR = 0;
//
//		//Determines the return type of Tensor by Tensor operations
//		using param_functor_type = typename Tensor_Operations_impl<param_deriv, param_traits>::functor_type;
//
//		using binary_type =
//				typename MTF::IF_ELSE<derived::RANK() != SCALAR && param_deriv::RANK() != SCALAR, //Neither are scalar
//						typename MTF::expression_substitution<binary_expression<scalar_type, functor, functor_type, param_functor_type>, derived>::type,
//						typename MTF::IF_ELSE<derived::RANK() == SCALAR && param_deriv::RANK() == SCALAR,
//							typename MTF::expression_substitution<binary_expression_scalar_LR<scalar_type, functor, functor_type, param_functor_type>, derived>::type,
//								typename MTF::IF_ELSE<derived::RANK() == SCALAR,
//									typename MTF::expression_substitution<binary_expression_scalar_L<scalar_type, functor, functor_type, param_functor_type>, derived    >::type,
//									typename MTF::expression_substitution<binary_expression_scalar_R<scalar_type, functor, functor_type, param_functor_type>, param_deriv>::type
//							>::type
//						>::type
//				>::type;
//
//		using unary_type = typename MTF::expression_substitution<unary_expression<scalar_type, functor, functor_type>, derived>::type;
//	};

//	//------------------- auto convert to scalar -----------------//
//	auto operator * (scalar_type scalar) const {
//		return (*this) * Scalar<scalar_type, math_library>(scalar);
//	}
//	auto operator + (scalar_type scalar) const {
//		return (*this) + Scalar<scalar_type, math_library>(scalar);
//	}
//	auto operator - (scalar_type scalar) const {
//		return (*this) - Scalar<scalar_type, math_library>(scalar);
//	}
//	auto operator / (scalar_type scalar) const {
//		return (*this) / Scalar<scalar_type, math_library>(scalar);
//	}
//	auto operator % (scalar_type scalar) const {
//		return (*this) % Scalar<scalar_type, math_library>(scalar);
//	}
//	auto& operator += (scalar_type scalar) const {
//		return (*this) += Scalar<scalar_type, math_library>(scalar);
//	}
//	derived& operator -= (scalar_type scalar) const {
//		return asBase() -= Scalar<scalar_type, math_library>(scalar);
//	}
//	derived& operator /= (scalar_type scalar) const {
//		return asBase() /= Scalar<scalar_type, math_library>(scalar);
//	}
//	auto& operator %= (scalar_type scalar) const {
//		return (*this) %= Scalar<scalar_type, math_library>(scalar);
//	}
