//};
//
//
//	//This doesn't actually give a shit if transposed --- just using this till I integrate blas
//	template<class A, class B, class C, class D, class E>
//	static void MatrixMul(bool transA, bool transB, const A a, const B b,  C c, int m, int n, int k, const D scalarA = nullptr, const E scalarB = nullptr,  int lda = 0, int ldb = 0, int ldc = 0) {
//		if (lda == 0 and ldb == 0 and ldc ==0) {
//			lda = m;
//			ldb = n;
//			ldc = m;
//		}
//
//		typename MTF::remove_mods<A>::type alpha =  scalarA == nullptr  ? 1 : *scalarA;
//		typename MTF::remove_mods<B>::type beta  =  scalarB == nullptr  ? 1 : *scalarB;
//
//#pragma omp parallel for
//		for (int z = 0; z < k; ++z) {
//			for (int x = 0; x < n; ++x) {
//				for (int y = 0; y < m; ++y) {
//					c[z * ldc + y] += (a[x * lda + y]* alpha) * (b[z * ldb + x] * beta);
//
//				}
//			}
//		}
//#pragma omp barrier
//	}
//
//	template<class T>
//	static void MatrixMul(bool transA, bool transB, const T a, const T b,  T c, int m, int n, int k, const T scalarA = nullptr, const T scalarB = nullptr,  int lda = 0, int ldb = 0, int ldc = 0) {
//		if (lda == 0 and ldb == 0 and ldc ==0) {
//			lda = m;
//			ldb = n;
//			ldc = m;
//		}
//
//		typename MTF::remove_mods<T>::type alpha =  scalarA == nullptr  ? 1 : *scalarA;
//		typename MTF::remove_mods<T>::type beta  =  scalarB == nullptr  ? 1 : *scalarB;
//
//#pragma omp parallel for
//		for (int z = 0; z < k; ++z) {
//			for (int x = 0; x < n; ++x) {
//				for (int y = 0; y < m; ++y) {
//					c[z * ldc + y] += (a[x * lda + y] * scalarA) * (b[z * ldb + x] * scalarB);
//
//				}
//			}
//		}
//#pragma omp barrier
//	}


	//padded correlation
	template<class V, class T, class U>
	static void x_correlation(V& cor, const T& krnl, const U& img, int krnl_rank, const int* krnl_shape, int img_size, int img_rows) {

		int krnl_col_count = 1;
		for (int i = 1; i < krnl_rank; ++i) {
			krnl_col_count *= krnl_shape[i];
		}

		const int krnl_rows = krnl_shape[0];			//
		const int cor_rows = krnl_rows + img_rows - 1;	//output image rows
		int base_ = krnl_rows - 1;	//the base offset for handling the initial edge case

		//handles the initial edge case
		for (int i = 0; i < base_; ++i){
			for (int j = 0; j < krnl_col_count; ++j)
				for (int k = base_ - 1; k > -1; --k) {
						//correlate the initial edge
					cor[i + (krnl_col_count - 1 - j) * cor_rows] += krnl[krnl_rows - k - 1 + j * krnl_rows] * img[i + k];
			}
		}


		//handles the rest of the kernel
		for (int i = 0; i < img_size; ++i) {
			std::cout << " i = " << i  << std::endl;
				bool incremented = false;
				//do for the number of "valid" positions
				//then
					for (int j = 0; j < krnl_col_count; ++j) {

						if (incremented) {
							incremented = false;
							base_--;
						}

						for (int k = 0; k < krnl_rows; ++k) {
						if (k != 0 && !incremented)
							//checks if the kernel the edge of a column increment the output offset
							if (std::floor((double)i / img_rows) < std::floor((double)(i + k)/ img_rows)) {
								//we want to do this everytime the kernel starts to overflow, but only once each overflow
								incremented = true;
								base_++;
							}

						cor[i+ j * cor_rows + base_] += krnl[k + (krnl_col_count - j - 1)  * krnl_rows] * img[i + k];
				}
			}
		}
	}
	//non - padded
	template<class V, class T, class U>
		static void x_correlation_in(V& cor, const T& krnl, const U& img, int krnl_rank, const int* krnl_shape, int img_size, int img_rows) {

			int krnl_col_count = 1;
			for (int i = 1; i < krnl_rank; ++i) {
				krnl_col_count *= krnl_shape[i];
			}

		const int krnl_rows = krnl_shape[0];
		const int positions = img_rows - krnl_rows + 1;
		int cor_base = 0;
		//handles the rest of the kernel
		for (int i = 0; i < img_size; ++i) {
			for (int p = 0; p < positions; ++p, ++i)
				for (int j = 0; j < krnl_col_count; ++j) {
					for (int k = 0; k < krnl_rows; ++k) {
						cor[cor_base + i] += krnl[k + j * krnl_rows] * img[i + k + j * img_rows];
					}
				}
		}
	}

