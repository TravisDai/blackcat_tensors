/*
 * Tensor_Functor_impl.cu
 *
 *  Created on: Feb 14, 2018
 *      Author: joseph
 */

#ifndef TENSOR_FUNCTOR_IMPL_CU_
#define TENSOR_FUNCTOR_IMPL_CU_

#include <type_traits>

namespace BC {



template<class scalar_type, class functor_type, class mathlib, int order, bool ownership = true>
struct Tensor_Functor_impl {

	struct DEFAULTER   { template<class... T> static void impl(const T&...) {} };
	struct INITIALIZER { template<class  T>   static void impl(T*& param, int sz) { mathlib::initialize(param, sz); } };
	struct DESTROYER   { template<class  T>   static void impl(T*& param)		  { mathlib::destroy(param); } };
	template<bool, class a, class b = DEFAULTER>

	struct function_if : a{};
	struct ScalarCore;
	struct MatrixCore;
	struct VectorCore;

	using functor = typename std::conditional<order == 0, ScalarCore,
						typename std::conditional<order == 1, VectorCore, MatrixCore>::type>::type;

	functor array;

	const functor& expression_packet() const  { return array; }



struct ScalarCore {

	functor_type array;

	template<class... params>
	ScalarCore(const params&... p) : array(p...) {
		function_if<sizeof...(params) == 0, INITIALIZER>::impl(array, 1);
	}
	~ScalarCore() { function_if<ownership, DESTROYER>::impl(array); }
};
struct VectorCore {

	int m;
	functor_type array;

	template<class... params>
	VectorCore(int m_, const params&... p) : array(p...), m(m_) {
		function_if<sizeof...(params) == 0, INITIALIZER>::impl(array, m);
	}
	~VectorCore() { function_if<ownership, DESTROYER>::impl(array); }

};
struct MatrixCore {

	int m;
	int n;
	int sz = m * n;
	functor_type array;

	template<class... params>
	MatrixCore(int m_, int n_ = 1, const params&... p) : array(p...), m(m_), n(n_) { function_if<sizeof...(params) == 0, INITIALIZER>::impl(array, sz); }
	~MatrixCore() { function_if<ownership, DESTROYER>::impl(array); }

};


};




}


#endif /* TENSOR_FUNCTOR_IMPL_CU_ */
