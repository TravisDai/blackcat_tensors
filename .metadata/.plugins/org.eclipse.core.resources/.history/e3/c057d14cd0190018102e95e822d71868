/*
 * Scalar.h
 *
 *  Created on: Jan 6, 2018
 *      Author: joseph
 */

#ifndef SCALAR_H_
#define SCALAR_H_
#include "TensorBase.h"
#include "../BC_MetaTemplateFunctions/Simple.h"

namespace BC {

template<class T, class Mathlib>
class Scalar : public TensorBase<T, Scalar<T, Mathlib>, Mathlib, Rank<0>> {

	using parent_class = TensorBase<T, Scalar<T, Mathlib>, Mathlib, Rank<0>>;
	template<class, class> friend class Vector;

public:
	static constexpr int RANK() { return 0; }

	using parent_class::operator=;

	Scalar() {}
	Scalar(const Scalar&& t) : parent_class(t) 		{}
	Scalar(		 Scalar&& t) : parent_class(t) 		{}
	Scalar(const Scalar&  t) : parent_class(t) 		{}

	Scalar& operator =(const Scalar&  t) { return parent_class::operator=(t); }
	Scalar& operator =(const Scalar&& t) { return parent_class::operator=(t); }
	Scalar& operator =(	     Scalar&& t) { return parent_class::operator=(t); }
	template<class U>
	Scalar& operator =(const Scalar<U, Mathlib>& t) { return parent_class::operator=(t); }
	Scalar& operator =(T scalar) { Mathlib::DeviceToHost(this->data(), &scalar, 1); return *this; }

	using _shape = std::vector<int>;
	using MTF::ifte;
	using MTF::isPrim;
	Scalar(T* param) {}

	template<class u> struct sendParam { static auto impl(const u& param) { return param; }};
	template<class u> struct sendNull { static auto impl(const u& param) { return nullptr; }};
	template<class... u> struct htd { static void impl(const u&... param) { Mathlib::HostToDevice(param...); }};
	template<class... u> struct voider { static void impl(const u&... parma) { }};

	Scalar(T value) : parent_class(ifte<isPrim<decltype(value), sendParam, sendNull>::impl(value)) {
		Mathlib::HostToDevice(this->data().ary(), &value, 1);
	}
};


}



#endif /* SCALAR_H_ */
