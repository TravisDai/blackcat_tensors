/*
 * Tensor_Base.h
 *
 *  Created on: Jan 6, 2018
 *      Author: joseph
 */

#ifndef TENSOR_BASE_H_
#define TENSOR_BASE_H_


#include "Implementation_Core/Tensor_Operations.h"
#include "Implementation_Core/Tensor_Utility.h"
#include "Implementation_Core/Tensor_Core.cu"
#include "../BC_MathLibraries/Mathematics_CPU.h"
#include "../BC_MathLibraries/Mathematics_GPU.cu"


namespace BC {

using MTF::ifte;
using MTF::prim;

template<class> struct det_rank;
template<class a, class b> struct det_rank<Vector<a,b>> { static constexpr bool value = 1; };
template<class a, class b> struct det_rank<Matrix<a,b>> { static constexpr bool value = 2; };
template<class a, class b> struct det_rank<Scalar<a,b>> { static constexpr bool value = 0; };

template<class> struct isCore { static constexpr bool conditional = false; };
template<class a, class b, class c> struct isCore<Tensor_Core<a, b, c>>
{ static constexpr bool conditional = true; };
template<class T>
using isCore_t = isCore<T>;

template<class> struct internal;
template<class t, class ml, template<class,class> class tensor> struct internal<tensor<t, ml>> {
	template<class T, class ML>
	using type = tensor<T, ML>;
};

template<class T> struct shell_of {
	template<class... ntraits>
			using type = void;
};
template<template<class...> class param, class... ptraits>
struct shell_of<param<ptraits...>> {
		template<class... ntraits>
		using type = param<ntraits...>;
};

template<class a, class b> struct same_shell{
	static constexpr bool val = false;
};
template<template<class...> class T, class... a, class... b>
struct same_shell<T<a...>, T<b...>> {
	static constexpr bool val = true;

};

template<class T, class derived, class Mathlib, class R>
class TensorBase :
				public Tensor_Operations <T, ifte<prim<T>, Tensor_Core<T, Mathlib, R>, T>, derived, Mathlib>,
				public Tensor_Utility    <T, derived, Mathlib, prim<T> | isCore_t<T>::conditional>

{

protected:
	struct DISABLED;
	using accessor = Tensor_Core<T, Mathlib, R>;
	using math_parent  = Tensor_Operations<T, ifte<prim<T>, Tensor_Core<T, Mathlib, R>, T>, derived, Mathlib>;
	using functor_type =  ifte<prim<T>, Tensor_Core<T, Mathlib, R>, T>;
	using child = typename Tensor_Core<T, Mathlib, R>::child;
	static constexpr bool genuine_tensor = prim<T> | isCore_t<T>::conditional;
	functor_type black_cat_array;

public:

	derived& operator = (const derived& tensor) {
		Mathlib::copy(this->data(), tensor.data(), this->size());
		return *this;
	}
	derived& operator = (derived&& tensor) {
		std::swap(black_cat_array, tensor.black_cat_array);
		return *this;
	}

	template<class... params> TensorBase(const params&... p) : black_cat_array(p...) { }

	template<class U> using deriv = typename shell_of<derived>::type<U, Mathlib>;
	template<class... U> using functor = typename shell_of<functor_type>::type<U...>;

	template<class U> TensorBase(const ifte<genuine_tensor, deriv<U>, DISABLE>& tensor) : black_cat_array(tensor.black_cat_array) {}
	template<class... U> TensorBase(const deriv<functor<U...>>& tensor) : black_cat_array(tensor.black_cat_array) {}

	TensorBase(		 derived&& tensor) : black_cat_array(tensor.black_cat_array){}
	TensorBase(const derived&  tensor) : black_cat_array(tensor.black_cat_array){}
	using math_parent::operator=;

	operator  const derived&() const { return static_cast<const derived&>(*this); }
	operator  		derived&() 		 { return static_cast<	    derived&>(*this); }

	int rank() const { return black_cat_array.rank(); }
	int size() const { return black_cat_array.size(); }
	int rows() const { return black_cat_array.rows(); }
	int cols() const { return black_cat_array.cols(); }
	int LD_rows() const { return black_cat_array.LD_rows(); }
	int LD_cols() const { return black_cat_array.LD_cols(); }
	void resetShape(std::vector<int> sh) { black_cat_array.resetShape(sh); }

	int dimension(int i)		const { return black_cat_array.dimension(i); }
	void printDimensions() 		const { black_cat_array.printDimensions();   }
	void printLDDimensions()	const { black_cat_array.printLDDimensions(); }

	const auto InnerShape() const 			{ return black_cat_array.InnerShape(); }
	const auto OuterShape() const 			{ return black_cat_array.OuterShape(); }
	const functor_type& _data() const { return black_cat_array; }
		  functor_type& _data()		  { return black_cat_array; }
};

}


#endif /* TENSOR_BASE_H_ */

