/*
 * Tensor_Base.h
 *
 *  Created on: Jan 6, 2018
 *      Author: joseph
 */

#ifndef TENSOR_BASE_H_
#define TENSOR_BASE_H_

#include "Implementation_Core/Tensor_Operations.h"
#include "Implementation_Core/Tensor_Utility.h"
#include "Implementation_Core/Tensor_Core.cu"
#include "Implementation_Core/Determiners.h"
namespace BC {
using MTF::isCorePure;
using MTF::isCore;
using MTF::ifte;

template<class derived>
class TensorBase : public Tensor_Operations <derived>, public Tensor_Utility<derived> {

protected:

	template<class> struct DISABLED;

	using self 			= TensorBase<derived>;

	//these are defined in Determiners.h
	using math_parent  	= Tensor_Operations<derived>;
	using functor_type 	= _functor<derived>;
	using Mathlib 		= _mathlib<derived>;
	using scal			= _scalar<derived>;

	template<class    U> using deriv   = typename shell_of<derived>::type<U, Mathlib>;
	template<class... U> using functor = typename shell_of<functor_type>::type<U...>;

	static constexpr int RANK 		= ranker<derived>::type::inner_rank;
	static constexpr int LD_RANK 	= ranker<derived>::type::outer_rank;
	static constexpr bool GENUINE_TENSOR = isCore<_functor<derived>>::conditional;

	functor_type black_cat_array;

public:
	using math_parent::operator=;

	operator  const derived&() const { return static_cast<const derived&>(*this); }
	operator  		derived&() 		 { return static_cast<	    derived&>(*this); }

	TensorBase(						 ) { if (RANK != 0) { throw std::invalid_argument("DEFAULT CONSTRUCTOR ONLY SUPPORTED FOR SCALARS"); } }


	struct passShape { template<class T> auto impl(const T& tensor) { return tensor.innerShape(); } };
	struct passArray { template<class T> auto impl(const T& tensor) { return tensor.black_cat_array; } };
	struct emptyFunction { template<class... T> static void impl(const T&... params) {} };
	struct copy			 { template<class T> static void impl(T& t, const T& u, int sz) { Mathlib::copy(t, u, sz); } };
	using control_initializer = ifte<GENUINE_TENSOR, passShape, passArray>;
	using control_copy		  = ifte<GENUINE_TENSOR, copy, emptyFunction>;

	TensorBase(		 derived&& tensor) : black_cat_array(control_initializer::impl(tensor)){ control_copy::impl(this->data(), tensor.data(), this->size());}
	TensorBase(const derived&  tensor) : black_cat_array(control_initializer::impl(tensor)){ control_copy::impl(this->data(), tensor.data(), this->size());}


//	TensorBase(		 derived&& tensor) : black_cat_array(tensor.black_cat_array){}
//	TensorBase(const derived&  tensor) : black_cat_array(tensor.black_cat_array){}



	template<class U>	//this is for constructing a genuine tensor from an expression
	TensorBase(const TensorBase<U>& tensor) : black_cat_array(shapeOf(tensor)) {
		this->assert_same_size(tensor);
		Mathlib::copy(this->black_cat_array, tensor.data(), this->size());
	}

	//the first parameter ensures the compiler differentiates between the default constructor and this constructor
	template<class param1, class... params>
	TensorBase(const param1& p1, const params&... p) : black_cat_array(p1, p...) { }


	derived& operator =(const derived& tensor) {
		this->assert_same_size(tensor);
		Mathlib::copy(this->data(), tensor.data(), this->size());
		return *this;
	}
	derived& operator =(	  derived&& tensor) {
		this->assert_same_size(tensor);
		std::swap(this->black_cat_array, tensor.black_cat_array);
		return *this;
	}

	int rank() const { return black_cat_array.rank(); }
	int size() const { return black_cat_array.size(); }
	int rows() const { return black_cat_array.rows(); }
	int cols() const { return black_cat_array.cols(); }
	int LD_rows() const { return black_cat_array.LD_rows(); }
	int LD_cols() const { return black_cat_array.LD_cols(); }
	void resetShape(std::vector<int> sh) { black_cat_array.resetShape(sh); }

	int dimension(int i)		const { return black_cat_array.dimension(i); }
	void printDimensions() 		const { black_cat_array.printDimensions();   }
	void printLDDimensions()	const { black_cat_array.printLDDimensions(); }

	const auto innerShape() const 			{ return black_cat_array.innerShape(); }
	const auto outerShape() const 			{ return black_cat_array.outerShape(); }


	const functor_type& _data() const { return black_cat_array; }
		  functor_type& _data()		  { return black_cat_array; }

	const auto slice(int i) const { return black_cat_array.slice(i); }
		  auto slice(int i) 	  { return black_cat_array.slice(i); }

		  auto operator [] (int i) 		 { return typename base<RANK>::slice<decltype(slice(0)), Mathlib>(slice(i)); }
	const auto operator [] (int i) const { return typename base<RANK>::slice<decltype(slice(0)), Mathlib>(slice(i)); }


	const auto getScalar(int i) const {
		return base<0>::type<Tensor_Scalar<functor_type>, Mathlib>(&this->data()[i], this->data());
	}
	auto getScalar(int i) {

		return base<0>::type<Tensor_Scalar<functor_type>, Mathlib>(&this->data()[i], this->data());
	}

	const auto operator() (int i) const { return getScalar(i); }
		  auto operator() (int i) 	    { return getScalar(i); }

	const auto operator() () const { return *this; }
		  auto operator() () 	   { return *this; }

	template<class... integers> const auto operator() (int i, integers... ints) const { return (*this)[i](ints...); }
	template<class... integers> 	  auto operator() (int i, integers... ints) 	  { return (*this)[i](ints...); }

	template<class var>
	static std::vector<int> shapeOf(const var& v) {
		std::vector<int> sh(v.rank());
		for (int i = 0; i < v.rank(); ++i) {
			sh[i] = v.dimension(i);
		}
		return sh;
	}
};

}


#endif /* TENSOR_BASE_H_ */

