//#ifdef  __CUDACC__
//#ifndef EXPRESSION_BINARY_DOTPRODUCT_CU_
//#define EXPRESSION_BINARY_DOTPRODUCT_CU_
//
//#include "Expression_Binary_Dotproduct_impl.cu"
//#include "Expression_Base.cu"
//#include "BlackCat_Internal_Definitions.h"
//#include "../BC_MetaTemplateFunctions/Adhoc.h"
//#include <iostream>
//#include <memory>
//#include <vector>
//
//namespace BC {
//
///*
// * a = M x K
// * b = K x N
// * c = M x N
// */
////det_Eval
//
//
//
//
//template<class T, class lv, class rv, class Mathlib>
//struct binary_expression_dotproduct : expression<T, binary_expression_dotproduct<T, lv, rv, Mathlib>> {
//	using scalar_type = typename MTF::determine_scalar<T>::type;
//
//	lv left;
//	rv right;
//
//	const int M = left.rows();
//	const int N = right.cols();
//	const int K = left.cols();
//	const int LDA = left.LD_rows();
//	const int LDB = right.LD_rows();
//	const int LDC = M;
//
//	const int lv_size = M * K;
//	const int rv_size = N * K;
//	const int eval_size = M * N ;
//	int is[2] = {M, N};
//	int os[2] = {M, N*M};
//
//	static constexpr bool transA = det_eval<lv>::transposed;
//	static constexpr bool transB = det_eval<rv>::transposed;
//	static constexpr bool lv_scalar = det_eval<lv>::scalar;
//	static constexpr bool rv_scalar = det_eval<rv>::scalar;
//	static constexpr bool lv_eval = det_eval<lv>::evaluate;
//	static constexpr bool rv_eval = det_eval<rv>::evaluate;
//
//	struct deleter {
//		template<class param>
//		void operator () (param& p) {
//			Mathlib::destroy(p);
//		}
//	};
//
//	std::shared_ptr<scalar_type> array;
//	scalar_type* array_ptr;
//
//	__attribute__((always_inline))
//	binary_expression_dotproduct(lv left, rv right) :
//	left(left), right(right), LDA(left.LD_rows()), LDB(right.LD_rows()) {
//
//		Mathlib::initialize(array_ptr,eval_size);
//		array = std::shared_ptr<scalar_type>(array_ptr, deleter());
//		eval();
//	}
//		__BCinline__ const T operator [](int index) const {
//			return array_ptr[index];
//		}
//		__BCinline__ T operator [](int index) {
//			return array_ptr[index];
//		}
//
//	__BCinline__ int size() const { return eval_size;}
//	__BCinline__ int rows() const { return M;}
//	__BCinline__ int cols() const { return N;}
//	__BCinline__ int rank() const { return right.rank(); }
//	__BCinline__ int LD_rows() const { return M; }
//	__BCinline__ int LD_cols() const { return eval_size; }
//	__BCinline__ int dimension(int i)		const { return i== 0 ? M : i == 1 ? N : 1; }
//	__BCinline__ const auto innerShape() 	const { return is; }
//	__BCinline__ const auto outerShape() 	const { return os; }
//
//
//
//	void printDimensions() 		const { std::cout<<"[" << M << "][" <<N  <<"]" << std::endl; }
//	void printLDDimensions()	const { std::cout<<"[" << M << "][" <<eval_size  <<"]" << std::endl; }
//
//
//public:
//
//	void eval() {
//
//		T* A = nullptr;
//		T* B = nullptr;
//		T* alpha = nullptr;
//		T* alpha2 = nullptr;
//
//		if (lv_eval) {
//			Mathlib::initialize(A, lv_size);
//			Mathlib::copy(A, left, lv_size);
//		} else {
//			A = det_eval<lv>::getArray(left);
//		}
//		if (rv_eval) {
//			Mathlib::initialize(B, rv_size);
//			Mathlib::copy(B, right, rv_size);
//		} else {
//			B = det_eval<rv>::getArray(right);
//		}
//			alpha = det_eval<lv>::getScalar(left);		//nullptr if !lv_scalar
//			alpha2 = det_eval<rv>::getScalar(right);	//nullptr if !rv_scalar
//
//
//			//if scalars on both sides we need to convert them into a single scalar (for it to work with blas)
//		if (lv_scalar && rv_scalar){
//			T* tmp;
//			Mathlib::initialize(tmp, 1);
//			Mathlib::scalarMul(tmp, alpha, alpha2);
//			Mathlib::MatrixMul(transA, transB, A, B, array_ptr, M, N, K, tmp, nullptr, LDA, LDB, LDC);
//			Mathlib::destroy(tmp);
//
//		} else if (rv_scalar)
//			 Mathlib::MatrixMul(transA, transB, A, B, array_ptr, M, N, K, alpha2, nullptr, LDA, LDB, LDC);
//		 else if (lv_scalar)
//			 Mathlib::MatrixMul(transA, transB, A, B, array_ptr, M, N, K, alpha, nullptr, LDA, LDB, LDC);
//		 else
//			 Mathlib::MatrixMul(transA, transB, A, B, array_ptr, M, N, K, nullptr, nullptr, LDA, LDB, LDC);
//
//		if (lv_eval)
//			Mathlib::destroy(A);
//		if (rv_eval)
//			Mathlib::destroy(B);
//
//	}
//
//
//	};
//}
//
//#endif /* EXPRESSION_BINARY_DOTPRODUCT_CU_ */
//#endif
//

/*
 * Expression_Binary_Dotproduct.cu
 *
 *  Created on: Jan 9, 2018
 *      Author: joseph
 */
#ifdef  __CUDACC__
#ifndef EXPRESSION_BINARY_DOTPRODUCT_CU_
#define EXPRESSION_BINARY_DOTPRODUCT_CU_

#include "Expression_Binary_Dotproduct_impl.cu"
#include "Expression_Base.cu"
#include "BlackCat_Internal_Definitions.h"
#include "../BC_MetaTemplateFunctions/Adhoc.h"
#include <iostream>
#include <memory>
#include <vector>

namespace BC {

/*
 * a = M x K
 * b = K x N
 * c = M x N
 */
//det_Eval

//template<class, class, class, class> 	class binary_expression_scalar_R;
//template<class, class, class, class> 	class binary_expression_scalar_L;
//template<class, class 			   > 	class unary_expression_transpose;
//template<class, class, class, class> 	class binary_expression;
//template<class>						 	class Tensor_Core;
//template<class>						 	class Tensor_Slice;
//template<class>						 	class Tensor_Scalar;
//
////										class mul;
//
template<class Find, class... from>
struct is_one_of {
	static constexpr bool value = false;
};
template<class Find, class front, class... from>
struct is_one_of<Find,front, from...> {
	static constexpr bool value = MTF::same<Find, front>::conditional || is_one_of<Find, from...>::value;
};



//template<class T, class lv, class rv, class Mathlib>
struct dp_impl {
	template<class class_> using TRANS = unary_expression_transpose<_scalar<class_>, class_>;
	template<class U, class l1, class l2> using BESR_mul = binary_expression_scalar_R<U, mul, l1, l2>;
	template<class U, class l1, class l2> using BESL_mul = binary_expression_scalar_L<U, mul, l1, l2>;
	template<class U, class l1, class l2> using BESR_trans_mul = binary_expression_scalar_R<U, mul, TRANS<l1>, l2>;
	template<class U, class l1, class l2> using BESL_trans_mul = binary_expression_scalar_L<U, mul, l1, TRANS<l2>>;


	template<class U> __BCinline__ static constexpr std::true_type isTransposed(const TRANS<U>&) { return std::true_type(); }
	template<class U, class lv, class rv>  __BCinline__ static constexpr std::true_type isTransposed(const BESR_trans_mul<U, lv, rv>&) { return std::true_type(); }
	template<class U, class lv, class rv>  __BCinline__ static constexpr std::true_type isTransposed(const BESL_trans_mul<U, lv, rv>&) { return std::true_type(); }
	template<class U> __BCinline__ static constexpr std::false_type isTransposed(const U&) { return std::false_type(); }

	template<class U, class lv, class rv>  __BCinline__ static constexpr std::true_type hasScalar(const BESR_trans_mul<U, lv, rv>&) { return std::true_type(); }
	template<class U, class lv, class rv>  __BCinline__ static constexpr std::true_type hasScalar(const BESL_trans_mul<U, lv, rv>&) { return std::true_type(); }
	template<class U, class lv, class rv>  __BCinline__ static constexpr std::true_type hasScalar(const BESR_mul<U, lv, rv>&) { return std::true_type(); }
	template<class U, class lv, class rv>  __BCinline__ static constexpr std::true_type hasScalar(const BESL_mul<U, lv, rv>&) { return std::true_type(); }
	template<class U> __BCinline__ static constexpr std::false_type hasScalar(const U&) { return std::false_type(); }

	template<class U> __BCinline__ static constexpr const auto getArray(const TRANS<U>& param) { return param.array; }
	template<class U> __BCinline__ static constexpr const auto getArray(const U& param) { return param; }
	template<class U, class lv, class rv>  __BCinline__  static constexpr const auto getArray(const BESR_trans_mul<U, lv, rv>& param) { return param.left; }
	template<class U, class lv, class rv>  __BCinline__  static constexpr const auto getArray(const BESL_trans_mul<U, lv, rv>& param) { return param.right; }

	template<class U> __BCinline__ static constexpr const auto& getScalar(const U& param) { return param; }
	template<class U, class lv, class rv>  __BCinline__ static constexpr const auto getScalar(const BESR_trans_mul<U, lv, rv>& param) { return param.right; }
	template<class U, class lv, class rv>  __BCinline__ static constexpr const auto getScalar(const BESL_trans_mul<U, lv, rv>& param) { return param.left; }
	template<class U, class lv, class rv>  __BCinline__ static constexpr const auto getScalar(const BESR_mul<U, lv, rv>& param) { return param.right; }
	template<class U, class lv, class rv>  __BCinline__ static constexpr const auto getScalar(const BESL_mul<U, lv, rv>& param) { return param.left; }
};

template<class T> struct isTrue { static constexpr bool value = false; };
template<> struct isTrue<std::true_type> { static constexpr bool value = true; };

template<class T, class lv, class rv, class Mathlib>
struct binary_expression_dotproduct : expression<T, binary_expression_dotproduct<T, lv, rv, Mathlib>> {
	using scalar_type = typename MTF::determine_scalar<T>::type;
	using impl = dp_impl;

	static constexpr bool transA = isTrue<decltype(impl::isTransposed(std::declval<lv>()))>::value; //det_eval<lv>::transposed;
	static constexpr bool transB = isTrue<decltype(impl::isTransposed(std::declval<rv>()))>::value;
	static constexpr bool lv_scalar = isTrue<decltype(impl::hasScalar(std::declval<lv>()))>::value;
	static constexpr bool rv_scalar = isTrue<decltype(impl::hasScalar(std::declval<rv>()))>::value;

	lv left;
	rv right;

	decltype(impl::getArray(std::declval<lv>())) A;    //= impl::getArray(left);
	decltype(impl::getScalar((std::declval<lv>()))) scalA; //= impl::getScalar(left);
	decltype(impl::getArray((std::declval<rv>()))) B; //= impl::getArray(right);
	decltype(impl::getScalar((std::declval<rv>()))) scalB;// = impl::getScalar(right);

	__BCinline__ binary_expression_dotproduct(lv left, rv right) : left(left), right(right),
	A(impl::getArray(left)), B(impl::getArray(right)),
	  scalA(impl::getScalar(left)), scalB(impl::getScalar(right))
	{}

	__BCinline__ int M()   const { return left.rows(); 		}
	__BCinline__ int N()   const { return right.cols(); 	}
	__BCinline__ int K()   const { return left.cols(); 		}
	__BCinline__ int LDA() const { return left.LD_rows(); 	}
	__BCinline__ int LDB() const { return right.LD_rows(); }
	__BCinline__ int LDC() const { return M(); }

	__BCinline__ int size() const { return M() * N();}
	__BCinline__ int rows() const { return M();}
	__BCinline__ int cols() const { return N();}
	__BCinline__ int rank() const { return right.rank(); }
	__BCinline__ int LD_rows() const { return M(); }
	__BCinline__ int LD_cols() const { return size(); }
	__BCinline__ int dimension(int i)		const { return i== 0 ? M() : i == 1 ? N() : 1; }
	__BCinline__ const auto innerShape() 	const { return generateDimList(M(), N()); }
	__BCinline__ const auto outerShape() 	const { return generateDimList(M(), size()); }

	void printDimensions() 		const { std::cout<<"[" << M() << "][" << N()  <<"]" << std::endl; }
	void printLDDimensions()	const { std::cout<<"[" << M() << "][" << size()  <<"]" << std::endl; }

	__BCinline__ T operator [](int index) const {
		T sum = 0;

		int COL = (int) (index / M());
		int ROW = (int) (index % M());

		if (!transA) {
			if (!transB) {
				int COL_BASE = COL * right.LD_rows();

				for (int i = 0; i < left.cols(); ++i) {
					sum += A[ROW + i * A.LD_rows()] * B[COL_BASE + i];
				}

			} else /* transB */ {
				for (int i = 0; i < left.cols(); ++i) {
					sum += A[ROW + i * A.LD_rows()] * B[COL + i * B.LD_rows()];
				}
			}
		} else {
			int ROW_BASE = ROW * left.LD_rows();

			if (!transB) {
				int COL_BASE = COL * right.LD_rows();

				for (int i = 0; i < left.cols(); ++i) {
					sum += A[ROW_BASE + i] * B[COL_BASE + i];
				}
			} else /* transB */ {
				for (int i = 0; i < left.cols(); ++i) {
					sum += A[ROW_BASE + i] * B[COL + i * B.LD_rows()];
				}
			}

		}

		if (lv_scalar)
			if (rv_scalar)
				return sum * scalA[0] * scalB[0];
			else
				return sum * scalA[0];
		else
			if (rv_scalar)
				return sum * scalB[0];
			else
				return sum;
	}




	};
}

#endif /* EXPRESSION_BINARY_DOTPRODUCT_CU_ */
#endif



//
//template<class T, class lv, class rv, class ml>
//struct binary_expression_dotproduct {
//
//	lv left;
//	rv right;
//
//	binary_expression_dotproduct(lv left_, rv right_) : left(left_), right(right_) {}
//
//	__BCinline__ T operator [] (int i) const {
//		int l_row = i % left.rows();
//		int l_base = l_row;
//
//		int r_col = (int)(i / left.rows());
//		int r_base = r_col * right.LD_rows();
//
//		T sum = 0;
//		for (int i = 0; i < left.cols(); ++i) {
//			sum += left[l_base + i * left.LD_rows()] * right[r_base + i];
//		}
//		return sum;
//	}
//		__BCinline__ int size() const { return left.rows() * right.cols();}
//		__BCinline__ int rows() const { return left.rows();}
//		__BCinline__ int cols() const { return right.cols();}
//		__BCinline__ int rank() const { return right.rank(); }
//		__BCinline__ int LD_rows() const { return left.rows(); }
//		__BCinline__ int LD_cols() const { return right.cols(); }
//		__BCinline__ int dimension(int i)		const { return i== 0 ? left.rows() : i == 1 ? right.cols() : 1; }
//		void printDimensions() const {}
//		void printLDDimensions() const {}
////		__BCinline__ const auto innerShape() 	const { return is; }
////		__BCinline__ const auto outerShape() 	const { return os; }
//};

//				Some printouts for debugging
//
//		std::cout << "dotproduct stats --------------------------------------------------------------------------" << std::endl;
//				std::cout << " m n k = " << M << "  "<< N << " " << K << std::endl;
//
//				if (lv_needs_to_be_evaluated) {
//					if (self_eval<lv>::conditioanl) {
//						std::cout << " lv self eval " << std::endl;
//					}
//					std::cout << " lv was evaluated " << std::endl;
//				}
//				if (rv_needs_to_be_evaluated) {
//					if (self_eval<rv>::conditioanl) {
//						std::cout << " rv self eval " << std::endl;
//					}
//					std::cout << " lv was evaluated " << std::endl;
//				}
//				if (transA) {
//					std::cout << " A - fast trans " << std::endl;
//				}
//				if (transB) {
//					std::cout << " B - fast trans " << std::endl;
//				}
//				if (evaluate<lv>::scalar) {
//					std::cout << " lv scalar detected " << std::endl;
//				}
//				if (evaluate<rv>::scalar) {
//					std::cout << " rv scalar detected " << std::endl;
//				}
//				if (scal_A && scal_B)
//				std::cout << "scalars = " << *scal_A <<  " " << *scal_B << std::endl;
//				std::cout << " --------------------------------------------------------------------------" << std::endl;


