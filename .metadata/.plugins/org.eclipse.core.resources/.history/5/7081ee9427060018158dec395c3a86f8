/*
 * Shape.h
 *
 *  Created on: Jan 18, 2018
 *      Author: joseph
 */

#ifndef SHAPE_H_
#define SHAPE_H_

#include <vector>

namespace BC {
class _expression {};
class _accessor {};
class _subAccessor {};
class _transpose {};
class _dotproduct {};
class _generic {};

using _shape = std::vector<int>;

#ifndef SHAPE_H_
#define SHAPE_H_

#include <vector>

namespace BC {
class _expression {};
class _accessor {};
class _subAccessor {};
class _transpose {};
class _dotproduct {};
class _generic {};

using _shape = std::vector<int>;

struct Shape {

	struct shape_packet {
		bool ownership = true;
		int order = is.size();
		int size;
		_shape is;
		_shape os;

		void re_init(_shape i) {
			os = _shape(i.size() - 1);
			os[0] = is[0];
			size = is[0];
			for (int i = 1; i < is.size(); ++i) {
				size *= is[i];
				os[i] = is[i] * os[i - 1];
			}
		}
		shape_packet(const shape_packet& pack) : is(pack.is), os(pack.os), size(pack.size), order(pack.order) {}
		shape_packet(shape_packet&& pack) : is(pack.is), os(pack.os), size(pack.size), order(pack.order) {}


		shape_packet(_shape i, _shape o, int sz, bool owner = true) : is(i), os(o), size(sz), ownership(owner) {}
		shape_packet(_shape i, bool owner = true) : is(i), ownership(owner)  {
			os = _shape(i.size() - 1);
			os[0] = is[0];
			size = is[0];
			for (int i = 1; i < is.size(); ++i) {
				size *= is[i];
				os[i] = is[i] * os[i - 1];
			}
		}
		shape_packet(_shape i, _shape o, bool owner = true) : is(i), os(o),ownership(owner)  {

			size = is[0];
			for (int i = 1; i < is.size(); ++i) {
				size *= is[i];
			}
		}

	};

public:
	static constexpr int COMPILE_TIME_ROWS() { return 0; }
	static constexpr int COMPILE_TIME_COLS() { return 0; }

	shape_packet sh;

	int rank() const { return sh.order; }
	int size() const { return sh.size;    }
	int rows() const { return sh.order > 0 ? sh.is[0] : 1; }
	int cols() const { return sh.order > 1 ? sh.is[1] : 1; }
	int dimension(int i) const { return sh.order > i ? sh.is[i] : 1; }
	void printDimensions() const { for (int i = 0; i < sh.order; ++i) { std::cout << "["<< sh.is[i] << "]"; } std::cout << std::endl; }

	int LD_rows() const { return sh.order > 1 ? sh.os[0] : 1; }
	int LD_cols() const { return sh.order > 2 ? sh.os[1] : 1; }
	int LDdimension(int i) const { return sh.order > i + 1 ? sh.os[i] : 1; }

	const int* InnerShape() const { return &sh.is[0]; }

	bool array_ownership = false;

	auto expression_packet() const  { return shape_packet(sh.is, sh.os, this->size()); }
	auto shape_copy_packet() const 	{ return shape_packet(sh.is, sh.os, this->size()); }

	auto accessor_packet() const    { return shape_packet(sh.is, sh.os, sh.order -1 , this->size() / sh.is[sh.order - 1]); }
	auto transpose_packet() const   { return shape_packet( {this->cols(), this->rows() }); }

	auto dotproduct_packet(int eval_order, const Shape& sh) const  {
		if (eval_order == 1) {
			return _shape({this->rows()});
		} else {
			return _shape({this->rows(), sh.cols()});
		}
	}
	auto subAccessor_packet(std::vector<int> is) const  { return shape_packet(sh.is, sh.os); }

	const Shape& asShape() const { return *this; }
	void ChangeShapeOwnership(bool swap = false) {
		array_ownership = false;
	}
	void resetShape(_shape is_) {
		sh.re_init(is_);
	}

	Shape(_shape param) : sh(param), array_ownership(true) {};
	Shape(shape_packet param) : sh(param), array_ownership(true) {};



};

}
#endif /* SHAPE_H_ */
