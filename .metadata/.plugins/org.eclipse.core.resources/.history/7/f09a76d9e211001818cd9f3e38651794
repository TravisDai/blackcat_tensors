/*
 * Tensor_Functor_impl.cu
 *
 *  Created on: Feb 14, 2018
 *      Author: joseph
 */

#ifndef TENSOR_FUNCTOR_IMPL_CU_
#define TENSOR_FUNCTOR_IMPL_CU_


namespace BC {



template<class scalar_type, class functor_type, class mathlib, int order, bool ownership = true>
struct Tensor_Functor_impl {

	struct DEFAULTER   { template<class... T> static void impl(const T&...) {} };
	struct INITIALIZER { template<class  T>   static void impl(T*& param, int sz) { mathlib::initialize(param, sz); } };
	struct DESTROYER   { template<class  T>   static void impl(T*& param)		  { mathlib::destroy(param); } };
	template<bool, class a, class b = DEFAULTER>

	struct function_if : a{};

	using functor = std::conditional<order == 0, ScalarCore,
						std::condtional<order == 1, VectorCore, MatrixCore>::type>::type;

	const Shape& expression_packet() const  { return *this; }



struct ScalarCore {

	functor_type array;

	template<class... params>
	ScalarCore(const params&... p) : array(p...) {
		function_if<sizeof...(params) == 0, INITIALIZER>::impl(array, 1);
	}
	~ScalarCore() { function_if<ownership, DESTROYER>::impl(array); }
};
struct VectorCore {

	int m;
	functor_type array;

	template<class... params>
	VectorCore(int m_, const params&... p) : array(p...), m(m_) {
		function_if<sizeof...(params) == 0, INITIALIZER>::impl(array, m);
	}
	~VectorCore() { function_if<ownership, DESTROYER>::impl(array); }

};
struct MatrixCore {

	int m;
	int n;
	int sz = m * n;
	functor_type array;

	template<class... params>
	MatrixCore(int m_, int n_ = 1, const params&... p) : array(p...), m(m_), n(n_) { function_if<sizeof...(params) == 0, INITIALIZER>::impl(array, sz); }
	~MatrixCore() { function_if<ownership, DESTROYER>::impl(array); }

};



auto shape_copy_packet() const 	{ return Shape(is, os, order, sz, true); }
auto accessor_packet() const    { return Shape(is, os, order - 1, sz/is[order - 1], false); }
auto transpose_packet() const   { return Shape({this->cols(), this->rows()}, os, 2, sz, false); }
auto dotproduct_packet(int eval_order, const Shape& sh) const {

	return eval_order == 1 ?
			Shape({this->rows()}) :
			Shape({this->rows(), sh.cols()});
}
auto subAccessor_packet(_shape is_) const  { return Shape(is_, os, order, sz, false); }








};




}


#endif /* TENSOR_FUNCTOR_IMPL_CU_ */
