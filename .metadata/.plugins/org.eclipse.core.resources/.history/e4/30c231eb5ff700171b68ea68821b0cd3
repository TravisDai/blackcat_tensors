#include <iostream>
#include <omp.h>
#include "math.h"
#include "time.h"

#include "BlackCat_Tensors.h"


using BC::Vector;

template<int SIZE, int repetitions>
int speedTests() {
	const int reps = repetitions;

	std::cout << "  ------------------------------------------ speed tests ------------------------------------------" << std::endl;
	std::cout << " size = " << SIZE << std::endl;
	std::cout << " Repetitions = " << reps << std::endl;

	using vec = Vector<double, SIZE>;
//	using vec = Vector<double, SIZE, BC::GPU>;
	vec at;
	vec bt;
	vec ct;
	vec dt;

	bt.randomize(0, 1000);
	ct.randomize(0, 1000);
	bt.randomize(0, 1000);

	at.zeros();


	float t;

	t = omp_get_wtime();
	printf("\n Calculating... (BlackCat_Tensors) (a = b + c + d + b * b + c * c + ) \n");
	for (int i = 0; i < reps; ++i) {
		(at = bt + ct + ct + bt % bt + ct % ct + ct - bt);//.direct_eval();
	}

//	at.print();

	t = omp_get_wtime() - t;
	printf("It took me %f clicks (%f seconds).\n", t, ((float) t));


//	t = omp_get_wtime();
//	printf("\n Calculating... BlackCat Manual for loop zeroing (iteration speed)) \n");
//	for (int j = 0; j < reps; ++j)
//		for (int i = 0; i < SIZE; ++i) {
//			at[i] = 0;
//		}
//
//	t = omp_get_wtime() - t;
//
//	printf("It took me %d clicks (%f seconds).\n", t, ((float) t));
//
//	t = omp_get_wtime();
//	printf("\n Calculating... BlackCat Manual for loop adding 1 (iteration speed)) \n");
//	for (int j = 0; j < reps; ++j)
//		for (int i = 0; i < SIZE; ++i) {
//			at[i] = at[i] + 1;
//		}
//
//	t = omp_get_wtime() - t;
//
//	printf("It took me %d clicks (%f seconds).\n", t, ((float) t));



	std::cout << "success " << std::endl;

#pragma omp barrier
	return 0;
}

#include <iostream>
#include <math.h>
// Kernel function to add the elements of two arrays
__global__
void add(int n, float *x, float *y)
{
	for (int j = 0; j < n; ++j)
  for (int i = 0; i < n; i++)
    y[i] = x[i] + y[i] + x[i] + y[i] + x[i] + y[i] +  x[i] + y[i] +  x[i] + y[i];
}

void add2(int n, float* x, float * y) {
	for (int j = 0; j < n; ++j)
	  for (int i = 0; i < n; i++)
	    y[i] = x[i] + y[i] + x[i] + y[i] + x[i] + y[i] +  x[i] + y[i] +  x[i] + y[i];
}

int cudaTest(void)
{
  int N = 1000;
  float *x, *y;

  // Allocate Unified Memory – accessible from CPU or GPU
  cudaMallocManaged(&x, N*sizeof(float));
  cudaMallocManaged(&y, N*sizeof(float));

  // initialize x and y arrays on the host
  for (int i = 0; i < N; i++) {
    x[i] = 1.0f;
    y[i] = 2.0f;
  }

	std::cout << "cuda adding " << N  << "ele" << std::endl;


	float t = omp_get_wtime();

  // Run kernel on 1M elements on the GPU
	int blockSize = 256;
	int numBlocks = (N + blockSize - 1) / blockSize;
  add<<<numBlocks, blockSize>>>(N, x, y);
  cudaDeviceSynchronize();


  t = omp_get_wtime() - t;


  	printf("It took me %f clicks (%f seconds).\n", t, ((float) t));

  // Wait for GPU to finish before accessing on host

  // Check for errors (all values should be 3.0f)
  float maxError = 0.0f;
  for (int i = 0; i < N; i++)
    maxError = fmax(maxError, fabs(y[i]-3.0f));
  std::cout << "Max error: " << maxError << std::endl;

  // Free memory
  cudaFree(x);
  cudaFree(y);

  return 0;
}

int regTest(void)
{
  int N = 1000;
  float *x, *y;

  // Allocate Unified Memory – accessible from CPU or GPU
  x = new float[N];
  y = new float[N];
  // initialize x and y arrays on the host
  for (int i = 0; i < N; i++) {
    x[i] = 1.0f;
    y[i] = 2.0f;
  }

	std::cout << "cpu adding " << N  << "ele" << std::endl;


	float t = omp_get_wtime();

  // Run kernel elements on the GPU

  add2(N, x, y);


  t = omp_get_wtime() - t;


  	printf("It took me %f clicks (%f seconds).\n", t, ((float) t));

  // Wait for GPU to finish before accessing on host

  // Check for errors (all values should be 3.0f)
  float maxError = 0.0f;
  for (int i = 0; i < N; i++)
    maxError = fmax(maxError, fabs(y[i]-3.0f));
  std::cout << "Max error: " << maxError << std::endl;

  // Free memory
  cudaFree(x);
  cudaFree(y);

  return 0;
}

int main() {
	regTest();
	cudaTest();
//
//	speedTests<100000, 10000>();
//	speedTests<10000, 10000>();
//	speedTests<1000, 10000>();
//	speedTests<100, 10000>();
//	speedTests<10, 10000>();

//	speedTests<10000, 100000>();

//	speedTests<10, 100>();

	return 0;
}


