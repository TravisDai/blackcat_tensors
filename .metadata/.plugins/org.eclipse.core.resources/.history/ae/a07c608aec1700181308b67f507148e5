

/*
 * Shape.h
 *
 *  Created on: Jan 18, 2018
 *      Author: joseph
 */

#ifndef SHAPE_H_
#define SHAPE_H_

#include <vector>
#include "../../BC_MetaTemplateFunctions/Adhoc.h"
#include "../../BC_Expressions/BlackCat_Internal_Definitions.h"
#include "../../BC_Expressions/Expression_Base.cu"

#include <iostream>
namespace BC {
template<class T, class Mathlib, class ranker> struct Tensor_Core;

#define __BC_gcpu__ __host__ __device__

using MTF::prim; //isPrimitive
using MTF::ifte; //if then else

template<int inner_rank_, int outer_rank_ = inner_rank_, class voider = void>
struct Rank {
	static constexpr int inner_rank = inner_rank_;
	static constexpr int outer_rank = outer_rank_;
};


static constexpr int MAXDIM = 100;
static constexpr int MINDIM = 0;

static constexpr int max(int a, int b) { return a > b ? a : b; }
static constexpr int min(int a, int b) { return a < b ? a : b; }
static constexpr int higher(int a) { return max(MAXDIM, max(a + 1, MINDIM)); }
static constexpr int lower(int a) { return min(MINDIM, min(a - 1, MAXDIM)); }

struct _sh {
	operator const int*() const { return dims; }

	_sh(const int* d) : dims(d) {}
	const int* dims;
};

template<class T, class Mathlib, int inner, int outer>
struct Tensor_Core<T, Mathlib, Rank<inner, outer>> : expression<T, Tensor_Core<T, Mathlib, Rank<inner, outer>>> {

	template<class,class,class> friend class Tensor_Core;

	friend class Tensor_Core<T, Mathlib, Rank<higher(inner), outer>>;
	friend class Tensor_Core<T, Mathlib, Rank<lower(inner), outer>>;

	using child = Tensor_Core<T, Mathlib, Rank<lower(inner), outer>>;
	using parent = Tensor_Core<T, Mathlib, Rank<higher(inner), outer>>;

	using dimlist = std::vector<int>;
	using scalar = typename MTF::determine_scalar<T>::type;

	static constexpr int RANK = inner;
	static constexpr int LD_RANK = outer;
	static constexpr bool OWNERSHIP = RANK == LD_RANK;
	static constexpr int LAST = RANK - 1;

	using shape = ifte<OWNERSHIP, int[RANK], int*>;

	scalar* array;
	shape is;
	shape os;

		  scalar* ary() 	  { return array; }
	const scalar* ary() const { return array; }

	operator 	   scalar*()       { return array; }
	operator const scalar*() const { return array; }

	__BC_gcpu__	      scalar& operator [] (int index) 		{ return array[index]; };
	__BC_gcpu__	const scalar& operator [] (int index) const { return array[index]; };


	Tensor_Core() {
		Mathlib::initialize(array, 1);
	}

	Tensor_Core(dimlist param) {
		Mathlib::copy(is, &param[0], RANK);
		if (RANK > 0) {
			os[0] = is[0];
			for (int i = 1; i < RANK; ++i) {
				os[i] = os[i - 1] * is[i];
			}
		}
		std::cout << " dimlistinit sh " << std::endl;

		Mathlib::initialize(array, size());
	}

	Tensor_Core(const Tensor_Core& param) {
		if (!OWNERSHIP)	//disable this later
			throw std::invalid_argument("copy on non-ownership tensor");

		Mathlib::copy(is, param.is, RANK);
		Mathlib::copy(os, param.os, RANK);
			os[0] = is[0];
			for (int i = 1; i < RANK; ++i) {
				os[i] = os[i - 1] * is[i];
			}

			std::cout << " copy const sh " << std::endl;

		Mathlib::initialize(array, size());
		Mathlib::copy(array, param.array, size());
	}
	Tensor_Core(Tensor_Core&& param) {
		if (!OWNERSHIP)	//disable this later
			throw std::invalid_argument("copy on non-ownership tensor");

		Mathlib::copy(is, param.is, RANK);
		Mathlib::copy(os, param.os, RANK);

		std::cout << " move " << std::endl;

		array = param.array;

		param.array = nullptr;
	}
	template<class t, class m, class r>
	Tensor_Core(const Tensor_Core<t, m, r>& param) {
		static_assert(RANK == decltype(param)::RANK, "TENSORS MAY ONLY BE CONSTRUCTED OF SAME ORDER ");

		Mathlib::copy(is, param.is, RANK);
		Mathlib::copy(os, param.os, RANK);
		std::cout << " initializing copy " << std::endl;

		Mathlib::initialize(array, size());
		Mathlib::copy(array, param.array, size());
	}
	Tensor_Core(_sh param) {
		Mathlib::copy(is, &param[0], RANK);
		if (RANK > 0) {
			os[0] = is[0];
			for (int i = 1; i < RANK; ++i) {
				os[i] = os[i - 1] * is[i];
			}
		}
		std::cout << " initializing sh " << std::endl;
		std::cout << " this rank = " << RANK << std::endl;
		std::cout <<  " this size = " << size() << std::endl;
		Mathlib::initialize(array, size());
	}

	~Tensor_Core() {
		if (OWNERSHIP)
			if (array)
		Mathlib::destroy(array);
	}

	__BC_gcpu__ int rank() const { return RANK; }
	__BC_gcpu__ int size() const { return RANK > 0 ? os[LAST] : 1;    }
	__BC_gcpu__ int rows() const { return RANK > 0 ? is[0] : 1; }
	__BC_gcpu__ int cols() const { return RANK > 1 ? is[1] : 1; }
	__BC_gcpu__ int dimension(int i) const { return RANK > i ? is[i] : 1; }

	__BC_gcpu__ int LD_rows() const { return RANK > 0 ? os[0] : 1; }
	__BC_gcpu__ int LD_cols() const { return RANK > 1 ? os[1] : 1; }
	__BC_gcpu__ int LDdimension(int i) const { return RANK > i + 1 ? os[i] : 1; }


	const auto InnerShape() const { return _sh(is); }
	const auto OuterShape() const { return _sh(os); }

	__BC_gcpu__ const scalar* data() const { return array; }
	__BC_gcpu__ scalar* data()  		   { return array; }

	void print() const { Mathlib::print(array, InnerShape(),rank(), 4); }

	void printDimensions() const {
		for (int i = 0; i < RANK; ++i) {
			std::cout << "[" << is[i] << "]";
		}
		std::cout << std::endl;
	}
	void printLDDimensions() const {
		for (int i = 0; i < RANK; ++i) {
			std::cout << "[" << os[i] << "]";
		}
		std::cout << std::endl;
	}

	void resetShape(dimlist sh)  {
		os[0] = sh[0];
		is[0] = sh[0];
		for (int i = 1; i < RANK; ++i) {
			is[i] = sh[i];
			os[i] = os[i - 1] * is[i];
		}
	}
};
}

#endif /* SHAPE_H_ */

