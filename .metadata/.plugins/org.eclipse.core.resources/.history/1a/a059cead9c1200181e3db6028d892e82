/*
 * TensorBase.h
 *
 *  Created on: Feb 15, 2018
 *      Author: joseph
 */

#ifndef TENSORBASE_H_
#define TENSORBASE_H_

#include "Expression.h"
#include "Expression_Binary_Functors.cu"
#include "Simple.h"
namespace BC {


template<int order>
struct Shape {

};
template<>
struct Shape<0> {

};
template<>
struct Shape<1> {
	int m;
};
//int m;
//int n;
//int sz;
//
//scalar* array;
template<class derived, class scalar>
struct TensorBase {

	operator const derived&() { return static_cast<const derived&>(*this); }
	operator 	   derived&() { return static_cast<		 derived&>(*this); }

	template<class d, class s> auto operator +(const TensorBase<d,s>& tens) const {
		bp_expr<add, derived&, TensorBase<d, s>::derived>(*this, tens);
	}
	template<class d, class s> auto operator -(const TensorBase<d,s>& tens) const {
		bp_expr<sub, derived&, TensorBase<d, s>::derived>(*this, tens);
	}
	template<class d, class s> auto operator /(const TensorBase<d,s>& tens) const {
		bp_expr<div, derived&, TensorBase<d, s>::derived>(*this, tens);
	}
	template<class d, class s> auto operator &(const TensorBase<d,s>& tens) const {
		bp_expr<div, derived&, TensorBase<d, s>::derived>(*this, tens);
	}
};

template<bool var, class A, class B>
using elif = std::conditional<var, A, B>::type;

struct functor_ {
	elif<ownership, int[order], int*> is;
	elif<ownership, int[order], int*> os;
	elif<MTF::isPrimitive<scalar>::conditional, scalar*, DISABLE> array;
};

template<class> struct derived_shell;
template<template<class...> class T, class... set> struct derived_shell<T<set...>>
{ template<class... p> using type = T<p...>; };

template<class derived, class scalar, int order, class ml>
struct TensorCore {
	static constexpr int comp_order() { return order; }

	template<class sub> using derived_body = derived_shell<sub, ml>;
	struct DISABLE {};
	using functor = elif<MTF::isPrimitive<scalar>::conditional, functor_, scalar>;


	template<class sub>
	using ret_type = elif<comp_order() == 0, derived_body<param_deriv>;

};

#endif /* TENSORBASE_H_ */
