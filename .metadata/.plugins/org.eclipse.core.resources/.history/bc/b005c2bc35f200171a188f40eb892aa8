/*
 * BC_Tensor_Super_Ace.h
 *
 *  Created on: Nov 18, 2017
 *      Author: joseph
 */

#ifndef STATIC_SHAPE_H_
#define STATIC_SHAPE_H_

#include "../BlackCat_Internal_GlobalUnifier.h"
#include "Static_Shape_Impl.h"
#include "Shape_DefaultLD_Impl.h"
#include "template_to_array.h"
#include "binary_constructor_generator.h"

#include <type_traits>
#include <vector>


namespace BC {

	template<class...> struct _list;
	template<int>class Dynamic_Inner_Shape;
	template<int>class Dynamic_Outer_Shape;
	template<class>class DEFAULT_LD;



template<class Inner_Shape, class Outer_Shape = typename DEFAULT_LD<Inner_Shape>::type>
struct Tensor_Shape :
	MTF::IF_ELSE<Inner_Shape::isDynamic, Dynamic_Inner_Shape<Inner_Shape::RANK   >, Inner_Shape>::type,
	MTF::IF_ELSE<Outer_Shape::isDynamic, Dynamic_Outer_Shape<Outer_Shape::LD_RANK>, Outer_Shape>::type {
public:
	static constexpr bool LDisDefault = MTF::is_same<Outer_Shape, typename DEFAULT_LD<Inner_Shape>::type>::conditional;
	static constexpr bool Dynamic_Inner = Inner_Shape::isDynamic;
	static constexpr bool Dynamic_Outer = Outer_Shape::isDynamic;

	using outer_shape = Outer_Shape;
	using inner_shape = Inner_Shape;

};



	template<int... dimensions>
	struct Outer_Shape {

		using params = _list<>;

		static constexpr int LD_RANK = sizeof...(dimensions);
		static constexpr bool isDynamic = MTF::sum<dimensions...>::value == 0;

		void printLeadingDimensions() const { BC_Shape_Identity_impl::print<Outer_Shape<dimensions...>>(); }

		const auto getOuterShape() const {
			std::vector<int> sh(LD_RANK);
			template_to_array::f<Outer_Shape<dimensions...>>::fill(&sh[0]);
			  return sh;
		}

		constexpr int LD_size()  const { return BC_Shape_Identity_impl::size<dimensions...>();  }
		constexpr int LD_rows()  const { return BC_Shape_Identity_impl::row<dimensions...>();   }
		constexpr int LD_cols()  const { return BC_Shape_Identity_impl::col<dimensions...>();   }
		constexpr int LD_depth() const { return BC_Shape_Identity_impl::depth<dimensions...>(); }
		constexpr int LD_pages() const { return BC_Shape_Identity_impl::pages<dimensions...>(); }
		constexpr int LD_books() const { return BC_Shape_Identity_impl::books<dimensions...>(); }
		constexpr int LD_libraries() const { return BC_Shape_Identity_impl::libraries<dimensions...>(); }

		template<int dim_index> constexpr int LD_dimension() const { return BC_Shape_Identity_impl::dimension<dim_index, dimensions...>(); }
	};


	template<int ... dimensions>
	struct Inner_Shape {

		using params = _list<>;
		static constexpr int RANK = sizeof...(dimensions);
		static constexpr bool isDynamic = MTF::sum<dimensions...>::value == 0;

		void printDimensions() const { BC_Shape_Identity_impl::print<Inner_Shape<dimensions...>>(); }
		int passInner() { return 0; }

		const auto getShape() const {
			std::vector<int> sh(RANK);
			template_to_array::f<Inner_Shape<dimensions...>>::fill(&sh[0]);
			  return sh;
		}
		constexpr int order() const { return sizeof...(dimensions); }
		constexpr int size()  const { return BC_Shape_Identity_impl::size<dimensions...>();  }
		constexpr int rows()  const { return BC_Shape_Identity_impl::row<dimensions...>();   }
		constexpr int cols()  const { return BC_Shape_Identity_impl::col<dimensions...>();   }
		constexpr int depth() const { return BC_Shape_Identity_impl::depth<dimensions...>(); }
		constexpr int pages() const { return BC_Shape_Identity_impl::pages<dimensions...>(); }
		constexpr int books() const { return BC_Shape_Identity_impl::books<dimensions...>(); }
		constexpr int libraries() const { return BC_Shape_Identity_impl::libraries<dimensions...>(); }

		template<int dim_index> constexpr int dimension() const { return BC_Shape_Identity_impl::dimension<dim_index, dimensions...>(); }
	};

}
#endif /* STATIC_SHAPE_H_ */
