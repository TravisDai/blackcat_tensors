/*
 * TensorCore.h
 *
 *  Created on: Feb 14, 2018
 *      Author: joseph
 */

#ifndef TENSORCORE_impl_H_
#define TENSORCORE_implH_
#include <type_traits>
#include "../../BC_MetaTemplateFunctions/Simple.h"
#include "../../BlackCat_Internal_Definitions.h"

#include <vector>
namespace BC {

template<class T, int order, class ml, bool ownership = true>
struct TensorCore_impl {

	struct defaulter {
		template<class... U> __BC_gcpu__
		static void impl (const U&...) {}
	};

	struct deleter {
		template<class U> __BC_gcpu__
		static void impl(U param) {
			if (param)
			ml::destroy(param);
		}
	};
	struct initializer {
		template<class U> __BC_gcpu__
		static void impl(U*& param, int sz) {
			ml::initialize(param, sz);
		}
	};

	struct constCopy {
		template<class U> __BC_gcpu__
		static void impl(U& p1, const U& p2) {
			p1 = U(p2);
		}
	};
	struct mlCopy {
		template<class U> __BC_gcpu__
		static void impl(U& p1, const U& p2, int sz) {
			ml::copy(p1, p2, sz);
		}
	};
	struct swap {
		template<class U> __BC_gcpu__
		static void impl(U& p1, U& p2) {
			std::swap(p1, p2);
		}
	};
	struct fastCopy {
		template<class U> __BC_gcpu__
		static const auto& impl(const U& param) {
			return param;
		}
	};
	struct null_init {
		template<class U> __BC_gcpu__
		static const U* impl(const U& param) {
			return nullptr;
		}
	};

	template<bool value, class functor, class f2 = void>
	struct CONSTEXPR_IF : functor {}; //bool is true
	template<class functor> struct CONSTEXPR_IF<false, functor> : defaulter {};
	template<class f1, class f2> struct CONSTEXPR_IF<true, f1, f2> : f1 {};
	template<class f1, class f2> struct CONSTEXPR_IF<false, f1, f2> : f2 {};



	template<bool cond, class a, class b>
	using else_if = typename std::conditional<cond, a, b>::type;

	template<bool cond, class a, class b>
	using if_ = else_if<cond, a ,b>;

	using functor_array = else_if<MTF::isPrimitive<T>::conditional, T*, T>;
	using _shape = std::vector<int>;
	struct ScalarCore;
	struct VectorCore;
	struct MatrixCore;
	template<int> struct TensorCore;

	using type = if_<order == 0, ScalarCore,
					else_if<order == 1, MatrixCore, //same for vectors
						else_if<order == 2, MatrixCore,
							TensorCore<order>>>>;

	using functor_type = typename MTF::determine_functor<T>::type;

	struct ScalarCore {
	functor_array array;

	template<class... params> ScalarCore(const params&... p) : array(p) {}
	ScalarCore() {
		CONSTEXPR_IF<MTF::isPrimitive<T>::conditional, initializer>::impl(array, 1);
	}
	__BC_gcpu__ int rank() const { return order; }
	__BC_gcpu__ int size() const { return 0;   }
	__BC_gcpu__ int rows() const { return 0; }
	__BC_gcpu__ int cols() const { return 0; }
	__BC_gcpu__ int LD_rows() const { return 0; }
	__BC_gcpu__	int LD_cols() const { return 0; }

	__BC_gcpu__ int dim(int i) const { return 0; }
	__BC_gcpu__ int LD_dim(int i) const { return 0; }
	__BC_gcpu__ void printDimensions() const { std::cout << "[0]" << std::endl; }
	__BC_gcpu__ void resetShape(int i = 0) {};
	};

	struct MatrixCore {

		MatrixCore(const MatrixCore& mat)
		: m(mat.m), n(mat.n), sz(mat.sz),
		  array(CONSTEXPR_IF<MTF::isPrimitive<T>::conditional, null_init, fastCopy>::impl(mat.array))
		{
			CONSTEXPR_IF<MTF::isPrimitive<T>::conditional, initializer>::impl(array, sz);
			CONSTEXPR_IF<MTF::isPrimitive<T>::conditional, mlCopy>::impl(array, mat.array, sz);
		}

		MatrixCore(MatrixCore&& mat)
		: m(mat.m), n(mat.n), sz(mat.sz),
		  array(CONSTEXPR_IF<MTF::isPrimitive<T>::conditional, null_init, fastCopy>::impl(mat.array))
		{
			CONSTEXPR_IF<MTF::isPrimitive<T>::conditional && !ownership, initializer>::impl(array, sz);
			CONSTEXPR_IF<MTF::isPrimitive<T>::conditional && !ownership, mlCopy>::impl(array, mat.array, sz);
		}


		functor_array array;
		int m;
		int n;
		int sz = m * n;

		template<class... params>
		MatrixCore(int _m, int _n, const params&... p) : array(p), m(_m), n(_n) {}
		MatrixCore(int _m, int _n) : m(_m), n(_n),
				array(nullptr) {
			CONSTEXPR_IF<MTF::isPrimitive<T>::conditional, initializer>::impl(array, sz);
		}


		__BC_gcpu__ int rank() const { return order; }
		__BC_gcpu__ int rows() const { return m; }
		__BC_gcpu__ int cols() const { return n; }

		__BC_gcpu__ const int* InnerShape() const { return &length; }
		__BC_gcpu__ const int* OuterShape() const { return &length; }

		__BC_gcpu__ int LD_rows() const { return m; }
		__BC_gcpu__ int LD_cols() const { return m * n; }

		__BC_gcpu__ int dim(int i) const { return i == 0 ? m : i == 1  ? n : 1; }
		__BC_gcpu__ int LD_dim(int i) const { return i == 0 ? m : i == 1  ? m * n : 1; }

		__BC_gcpu__ void printDimensions() const { std::cout << "[" << m << "]" << "[" << n << "]" << std::endl; }
		__BC_gcpu__ void resetShape(int _m = 0, int _n = 0) { m = _m; n = _n;};
	};
};





//
//struct VectorCore {
//	int length;
//	functor_array array;
//	template<class... params>
//	VectorCore(int le, const params&... p) : array(p), length(le) {
//		CONSTEXPR_IF<MTF::isPrimitive<T>::conditional, initializer>::impl(array, length);
//	}
//
//	__BC_gcpu__ int rank() const { return order; }
//	__BC_gcpu__ int size() const { return length;    }
//	__BC_gcpu__ int rows() const { return length; }
//	__BC_gcpu__ int cols() const { return 1; }
//
//	__BC_gcpu__ const int* InnerShape() const { return &length; }
//	__BC_gcpu__ const int* OuterShape() const { return &length; }
//
//	__BC_gcpu__ int LD_rows() const { return length; }
//	__BC_gcpu__ int LD_cols() const { return 1; }
//
//	__BC_gcpu__ int dim(int i) const { return 0; }
//	__BC_gcpu__ int LD_dim(int i) const { return 0; }
//	__BC_gcpu__ void printDimensions() const { std::cout << "[" << length << "]" << std::endl; }
//	__BC_gcpu__ void resetShape(int le = 0) { length = le; };
//};






}



#endif /* TENSORCORE_H_ */
