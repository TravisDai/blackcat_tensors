

/*
 * Shape.h
 *
 *  Created on: Jan 18, 2018
 *      Author: joseph
 */

#ifndef SHAPE_H_
#define SHAPE_H_

#include "Tensor_Core_Slice.cu"
#include "../../BC_MathLibraries/Mathematics_CPU.h"

#include "Determiners.h"
namespace BC {

template<class T> struct Tensor_Core {

	static constexpr int inner = _rankOf<T>;
	static constexpr int outer = _rankOf<T>;
	using Mathlib = _mathlib<T>;

public:

	using self = Tensor_Core<T>;

	using dimlist = std::vector<int>;
	using scalar = _scalar<T>;

	static constexpr int RANK = _rankOf<T>;
	static constexpr int LD_RANK = RANK;
	static constexpr int LAST = RANK - 1;

	const bool OWNERSHIP = true;

	struct Core {

	scalar* array;
	int* is;
	int* os;

	};

	Core data;

public:

		  scalar* asPtr() 	    { return array(); }
	const scalar* asPtr() const { return array(); }

	operator 	   scalar*()       { return array(); }
	operator const scalar*() const { return array(); }



	__BC_gcpu__	      scalar& operator [] (int index) 		{ return data.array[index]; };
	__BC_gcpu__	const scalar& operator [] (int index) const { return data.array[index]; };


	Tensor_Core() {
		static_assert(RANK == 0, "DEFAULT CONSTRUCTOR FOR TENSOR_CORE ONLY AVAILABLE FOR RANK == 0 (SCALAR)");
		Mathlib::initialize(data.array, 1);
	}

	Tensor_Core(dimlist param) {

		if (param.size() != RANK)
			throw std::invalid_argument("dimlist- rank != TENSOR_CORE::RANK");

		if (RANK > 0) {
			CPU::copy(data.is, &param[0], RANK);

			data.os[0] = innerShape()[0];
			for (int i = 1; i < RANK; ++i) {
				data.os[i] = outerShape()[i - 1] * innerShape()[i];
			}
		}
		Mathlib::initialize(data.array, size());
	}
	Tensor_Core(int* param) {
		if (RANK > 0) {
			CPU::copy(innerShape(), &param[0], RANK);

			outerShape()[0] = innerShape()[0];
			for (int i = 1; i < RANK; ++i) {
				outerShape()[i] = outerShape()[i - 1] * innerShape()[i];
			}
		}
		Mathlib::initialize(array(), size());
	}

	Tensor_Core(const Tensor_Core& param) {
		CPU::copy(innerShape(), param.innerShape(), RANK);
		CPU::copy(outerShape(), param.outerShape(), RANK);
			outerShape()[0] = innerShape()[0];
			for (int i = 1; i < RANK; ++i) {
				outerShape()[i] = outerShape()[i - 1] * innerShape()[i];
			}

		Mathlib::initialize(array(), size());
		CPU::copy(array(), param.array(), size());
	}
	Tensor_Core(Tensor_Core&& param) {
		CPU::copy(innerShape(), param.innerShape(), RANK);
		CPU::copy(outerShape(), param.outerShape(), RANK);
		array() = param.array();
		param.array() = nullptr;
	}

	~Tensor_Core() {
		if (OWNERSHIP) {
		Mathlib::destroy(array());
		Mathlib::destroy(innerShape());
		Mathlib::destroy(outerShape());
		}

	}

	__BC_gcpu__ int rank() const { return RANK; }
	__BC_gcpu__ int size() const { return RANK > 0 ? outerShape()[LAST] : 1;    }
	__BC_gcpu__ int rows() const { return RANK > 0 ? innerShape()[0] : 1; }
	__BC_gcpu__ int cols() const { return RANK > 1 ? innerShape()[1] : 1; }
	__BC_gcpu__ int dimension(int i) const { return RANK > i ? innerShape()[i] : 1; }

	__BC_gcpu__ int LD_rows() const { return RANK > 0 ? outerShape()[0] : 1; }
	__BC_gcpu__ int LD_cols() const { return RANK > 1 ? outerShape()[1] : 1; }
	__BC_gcpu__ int LDdimension(int i) const { return RANK > i + 1 ? outerShape()[i] : 1; }
	__BC_gcpu__ const auto array() const { return data.array; }
	__BC_gcpu__ auto array() { return data.array; }

	const auto innerShape() const { return RANK > 0 ? data.is : &ONE; }
	const auto outerShape() const { return RANK > 0 ? data.os : &ONE; }

	const scalar* core() const { return array(); }
		  scalar* core()  	   { return array(); }

	void print() const { Mathlib::print(array(), this->innerShape(),rank(), 4); }

	void printDimensions() const {
		for (int i = 0; i < RANK; ++i) {
			std::cout << "[" << innerShape()[i] << "]";
		}
		std::cout << std::endl;
	}
	void printLDDimensions() const {
		for (int i = 0; i < RANK; ++i) {
			std::cout << "[" << outerShape()[i] << "]";
		}
		std::cout << std::endl;
	}

	void resetShape(dimlist sh)  {
		outerShape()[0] = sh[0];
		innerShape()[0] = sh[0];
		for (int i = 1; i < RANK; ++i) {
			innerShape()[i] = sh[i];
			outerShape()[i] = outerShape()[i - 1] * innerShape()[i];
		}
	}

public:
		  auto slice(int i) { return Tensor_Slice<self>(&array()[outerShape()[LAST - 1] * i], *this); }
	const auto slice(int i) const { return Tensor_Slice<self>(&array()[outerShape()[LAST - 1] * i], *this); }

};
}

#endif /* SHAPE_H_ */

