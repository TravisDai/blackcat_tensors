/*
 * Tensor_Initializer.h
 *
 *  Created on: Mar 3, 2018
 *      Author: joseph
 */

#ifndef TENSOR_INITIALIZER_H_
#define TENSOR_INITIALIZER_H_

#include "Determiners.h"
#include "Tensor_Core.cu"

namespace BC {


template<class derived, class expression_tensor = void>
class TensorInitializer {

	using self 			= TensorInitializer<derived>;

	using functor_type 	= _functor<derived>;
	using Mathlib 		= _mathlib<derived>;
	using scal			= _scalar<derived>;

public:

	functor_type black_cat_array;

	TensorInitializer(		 derived&& tensor) : black_cat_array(tensor.black_cat_array){}
	TensorInitializer(const  derived&  tensor) : black_cat_array(tensor.black_cat_array){}
	template<class... params>
	TensorInitializer(const  params&... p) : black_cat_array(p...) {}
};

template<class derived>
class TensorInitializer<derived, std::enable_if_t<MTF::isCorePure<derived>::conditional || MTF::isPrimitive<_scalar<derived>>::conditional>> {

	static constexpr int RANK = derived::RANK();

	using self 			= TensorInitializer<derived>;

	using functor_type 	= _functor<derived>;
	using Mathlib 		= _mathlib<derived>;
	using scal			= _scalar<derived>;
	using _shape 		= std::vector<int>;
protected:
	functor_type black_cat_array;
private:
	auto& asBase() 			   { return static_cast<	  derived&>(*this); }
	const auto& asBase() const { return static_cast<const derived&>(*this); }

public:



	TensorInitializer(derived&& tensor)
	{
		black_cat_array.is(tensor.black_cat_array.is);
		black_cat_array.os(tensor.black_cat_array.os);
		black_cat_array.array(tensor.black_cat_array.array);

		tensor.black_cat_array.is 		= nullptr;
		tensor.black_cat_array.os 		= nullptr;
		tensor.black_cat_array.array 	= nullptr;
	}

	TensorInitializer(const derived& tensor) : black_cat_array(tensor.innerShape()){
		Mathlib::copy(asBase().data(), tensor.data(), tensor.size());
	}
	TensorInitializer(_shape dimensions): black_cat_array(dimensions){}

	TensorInitializer() { static_assert(RANK == 0, "DEFAULT CONSTRUCTOR ONLY AVAILABLE TO SCALARS"); }

	template<class U>
	TensorInitializer(const typename shell_of<derived>::type<U>&  tensor) : black_cat_array(tensor.innerShape()) {
		Mathlib::copy(this->asBase().data(), tensor.data(), this->asBase().size());
	}
};
}



#endif /* TENSOR_INITIALIZER_H_ */
