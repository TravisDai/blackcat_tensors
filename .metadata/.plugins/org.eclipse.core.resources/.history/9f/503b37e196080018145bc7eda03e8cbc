/*
 * Vector.h
 *
 *  Created on: Dec 30, 2017
 *      Author: joseph
 */

#ifndef VECTOR_H_
#define VECTOR_H_

#include "Scalar.h"
#include "TensorBase.h"


namespace BC {
template<class T, class Mathlib>
class Vector : public TensorBase<T, Vector<T, Mathlib>, Mathlib> {

	template<class,class>
	friend class Vector;

	using parent_class = TensorBase<T, Vector<T, Mathlib>, Mathlib>;
	using _int = typename parent_class::subAccess_int;
	using __int = typename parent_class::force_evaluation_int;

public:
	using parent_class::operator=;
	static constexpr int RANK() { return 1; }

	Vector() {}
	Vector(const Vector&& t) : parent_class(t) 		{}
	Vector(		 Vector&& t) : parent_class(t) 		{}
	Vector(const Vector&  t) : parent_class(t) 		{}
	Vector(int dim) 		 : parent_class(Shape({dim}))  {}

	template<class U> 		  Vector(const Vector<U, Mathlib>&  t) : parent_class(t) {}
	template<class U> 		  Vector(	   Vector<U, Mathlib>&& t) : parent_class(t) {}
	template<class... params> Vector(Shape sh, const params&... p) : parent_class(sh, p...) {}

	Vector& operator =(const Vector&  t) { return parent_class::operator=(t); std::cout << " copy =" << std::endl; }
	Vector& operator =(const Vector&& t) { return parent_class::operator=(t); std::cout << " const move = " << std::endl;}
	Vector& operator =(	     Vector&& t) { return parent_class::operator=(t); std::cout << " non-const move = " << std::endl;}
	template<class U>
	Vector& operator = (const Vector<U, Mathlib>& t) { return parent_class::operator=(t); }

	Vector(std::initializer_list<T> sh) : parent_class(Shape({(int)sh.size()})) { Mathlib::HostToDevice(this->data(), sh.begin(), this->size()); }


	Scalar<T, Mathlib> operator[] (_int i) {
		return (Scalar<T, Mathlib>(this->accessor_packet(), &this->array[i]));
	}
	const Scalar<T, Mathlib> operator[] (_int i) const {
		return Scalar<T, Mathlib>(this->accessor_packet(), &this->array[i]);
	}
	const Vector<unary_expression_transpose<typename MTF::determine_scalar<T>::type, Vector<T, Mathlib>>, Mathlib> t() const {
		return Vector<unary_expression_transpose<typename MTF::determine_scalar<T>::type, Vector<T, Mathlib>>, Mathlib>(this->transpose_packet(), *this);
	}
	const Vector<T, Mathlib> operator () (int index, std::vector<int> sub_shape) const {
		return Vector<T, Mathlib>(this->subAccessor_packet(sub_shape), &this->data()[index]);
	}
	Vector<T, Mathlib> operator () (int index, std::vector<int> sub_shape) {
		return Vector<T, Mathlib>(this->subAccessor_packet(sub_shape), &this->data()[index]);
	}

};

} //End Namespace BC

#endif /* VECTOR_H_ */
