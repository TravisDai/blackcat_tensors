

#include <Eigen/Dense>
#include "../../BlackCat_Tensors.h"
#include <iostream>
#include <omp.h>
#include "time.h"
#include <omp.h>
#include <vector>

//using BC::Matrix;
//using Eigen::MatrixXd;

using namespace BC::NN_Functions;


template<int SIZE, int repetitions>
float PointwiseFunctionTiming() {
	const int reps = repetitions;


	BC::Matrix<double> bc_a(SIZE,SIZE);
	BC::Matrix<double> bc_b(SIZE,SIZE);
	BC::Matrix<double> bc_c(SIZE,SIZE);
	BC::Matrix<double> bc_d(SIZE,SIZE);
	BC::Matrix<double> bc_e(SIZE,SIZE);

	Eigen::MatrixXd eg_a(SIZE,SIZE);
	Eigen::MatrixXd eg_b(SIZE,SIZE);
	Eigen::MatrixXd eg_c(SIZE,SIZE);
	Eigen::MatrixXd eg_d(SIZE,SIZE);
	Eigen::MatrixXd eg_e(SIZE,SIZE);

	bc_a.randomize(0, 100);
	bc_b.randomize(0, 100);
	bc_c.randomize(0, 100);
	bc_d.randomize(0, 100);
	bc_e.randomize(0, 100);

	//copy to ensure same parameters
	for (int i = 0; i < SIZE * SIZE; ++i) {
		eg_a[i] = bc_a[i];
		eg_b[i] = bc_b[i];
		eg_c[i] = bc_c[i];
		eg_d[i] = bc_d[i];
		eg_e[i] = bc_e[i];
	}

	float t;

	t = omp_get_wtime();

	for (int i = 0; i < reps; ++i) {
		bc_a = bc_b + bc_c / bc_d - bc_e;
	}
	t = omp_get_wtime() - t;

	std::cout <<"Lazy = " << SIZE << "    " << t << std::endl;

	t = omp_get_wtime();

	for (int i = 0; i < reps; ++i) {
		eg_a = eg_b + eg_c / eg_d - eg_e;
	}

	t = omp_get_wtime() - t;


	std::cout <<"Inst = " << SIZE << "    " << t  << "\n" << std::endl;

	return 0;
}


template<int SIZE, int repetitions>
int speedTestCombine() {
	const int reps = repetitions;

	using vec = Vector<float>;

	vec x(SIZE);
	vec y(SIZE);
	vec z(SIZE);


	vec a(SIZE);
	vec b(SIZE);
	vec c(SIZE);
	vec d(SIZE);
	vec e(SIZE);
	vec f(SIZE);
	vec g(SIZE);
	vec h(SIZE);
	vec i(SIZE);

	a.randomize(0, 100);
	b.randomize(0, 100);
	c.randomize(0, 100);
	d.randomize(0, 100);
	e.randomize(0, 100);
	f.randomize(0, 100);

	g.randomize(0, 100);
	h.randomize(0, 100);
	i.randomize(0, 100);

	float t;

	t = omp_get_wtime();

	for (int iter = 0; iter < reps; ++iter) {
		x = a + b;
		y = e;
	}

	t = omp_get_wtime() - t;


	std::cout <<"sz = " << SIZE << t << std::endl;

	return 0;
}


