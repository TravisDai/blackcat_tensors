/*
 * TensorN.h
 *
 *  Created on: Feb 20, 2018
 *      Author: joseph
 */

#ifndef CUBE_h
#define CUBE_h

namespace BC {



template<class T,  class Mathlib>
class Cube<T, Mathlib> : public TensorBase<T, Tensor<T, Rank, Mathlib>, Mathlib, Rank<3>> {

	template<class,class>
	friend class Matrix;

	using parent_class = TensorBase<T, Cube<T, Mathlib>, Mathlib, Rank<3>>;

	template<bool if_, class then, class else_> using ifte = std::conditional_t<if_, then, else_>;
	struct DISABLED;

	static constexpr int acc_rank = rank - 1;

	template<class t, int r, class ml>
	using accessor_shell = ifte<rank == 0, DISABLED,
								ifte<rank == 1, Scalar<t, ml>,
									ifte<rank == 2, Vector<t, ml>,
										ifte<rank == 3, Matrix<t, ml>,
											Tensor<T, rank - 1, Mathlib>>>>>;

public:
	using scalar = T;
	using parent_class::operator=;
	using accessor = typename parent_class::accessor;
	static constexpr int RANK() { return 2; }

	Cube() {}
	Cube(const Cube&  v) : parent_class(v) {}
	Cube(		 Cube&& v) : parent_class(v) {}
	Cube(const Cube&& v) : parent_class(v) {}

	template<class... dims>
	Cube(dims... d) : parent_class(std::vector<int> {d...}) {}

	template<class U, int r>  Cube(const Cube<U, r, Mathlib>&  t) : parent_class(t) {}
	template<class U, int r>  Cube(	   Cube<U, r, Mathlib>&& t) : parent_class(t) {}
	template<class... params> Cube(const params&... p) : parent_class(p...) {}

	Cube& operator =(const Cube& t)  { return parent_class::operator=(t); }
	Cube& operator =(const Cube&& t) { return parent_class::operator=(t); }
	Cube& operator =(	     Cube&& t) { return parent_class::operator=(t); }
	template<class U, int r>
	Cube& operator = (const Cube<U, r, Mathlib>& t) { return parent_class::operator=(t); }

	Cube(std::vector<T> sh) : parent_class(sh) {}
	accessor_shell<accessor, acc_rank, Mathlib> operator [] (int index) { return accessor_shell<accessor, acc_rank, Mathlib>(this->accessor_packet(index)); }
	const accessor_shell<accessor, acc_rank, Mathlib> operator [] (int index) const { return accessor_shell<accessor, acc_rank, Mathlib>(this->accessor_packet(index)); }
};


}




#endif /* TENSORN_H_ */
