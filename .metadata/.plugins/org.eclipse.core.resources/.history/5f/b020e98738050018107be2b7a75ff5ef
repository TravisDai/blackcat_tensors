/*
 * Constructors.h
 *
 *  Created on: Jan 29, 2018
 *      Author: joseph
 */

#ifndef CONSTRUCTORS_H_
#define CONSTRUCTORS_H_

#include <type_traits>

#include "../../BC_MetaTemplateFunctions/Simple.h"
#include "../../BC_MetaTemplateFunctions/Adhoc.h"
#include "../../BC_MetaTemplateFunctions/Complex.h"

namespace BC {
/*
 * This class is a workaround for CUDA's lack of constexpr_if support.
 * Once constexpr_if is added this class will be obsolete
 *
 */


//Constructors for Expressions
template<class T, class derived, class ml, class enabler = void>
struct Constructors {

};

//Constructors for tensors
template<class T, class derived, class ml>
struct Constructors<T, derived, ml,  typename std::enable_if<MTF::isPrimitive<T>::conditional>::type> {
	derived& ConstructorAsBase() { return static_cast<derived&>(*this); }
	const derived& ConstructorAsBase() const { return static_cast<const derived&>(*this); }

	Constructors() : Shape() {Mathlib::initialize(ConstructorAsBase().data(), ConstructorAsBase().size());}

		template<class pass_type, class... params>
		Constructors(const shape_packet<pass_type>& exp, const params&... p) : shape(exp), array(p...) {}

		template<class pass_type>
		Constructors(const shape_packet<pass_type>& exp) : shape(exp) {
			Mathlib::initialize(ConstructorAsBase().data(), ConstructorAsBase().size());
		}
	//
	//	TensorBase(derived&& tensor) : shape(tensor.expression_packet()), array(tensor.data()) {
	//			tensor.changeOwnership(false);
	//			this->changeOwnership(true);
	//	}
	//	TensorBase(const derived& tensor) : shape(tensor.shape_copy_packet()),
	//			array(MTF::isPrimitive<T>::conditional ? nullptr : tensor.data()){
	//		if (MTF::isPrimitive<T>::conditional) {
	//		Mathlib::initialize(this->asBase().data(), this->size());
	//			Mathlib::copy(this->data(), tensor.data(), this->size());
	//		}
	//	}

		template<class U, class D> TensorBase(const TensorBase<U, D, Mathlib>& tensor) : shape(tensor.shape_copy_packet()) {
			Mathlib::initialize(this->asBase().data(), this->size());
			Mathlib::copy(this->data(), tensor.data(), this->size());
		}
	//	TensorBase(const TensorBase<T, derived, Mathlib>& tensor) : shape(tensor.shape_copy_packet()) {
	//		Mathlib::initialize(this->asBase().data(), this->size());
	//		Mathlib::copy(this->data(), tensor.data(), this->size());
	//	}
		TensorBase(const TensorBase<T, derived, Mathlib>& tensor)
			: shape(tensor.OWNERSHIP ? tensor.expression_packet() : tensor.shape_copy_packet()), array(tensor.OWNERSHIP ? tensor.array : nullptr) {
			if (!tensor.OWNERSHIP) {
			Mathlib::initialize(this->asBase().data(), this->size());
			Mathlib::copy(this->data(), tensor.data(), this->size());
			}
		}



		TensorBase(const T* param) :  array(const_cast<T*>(param)) {}
		TensorBase(std::initializer_list<int> dimensions) : Shape<inner_shape, outer_shape>(dimensions) {
			Mathlib::initialize(this->asBase().data(), this->size());
		}

		template<class... params>
		TensorBase(std::initializer_list<int> dimensions, params... p) : shape_parent(dimensions), array(p...) {}


};


}


#endif /* CONSTRUCTORS_H_ */
