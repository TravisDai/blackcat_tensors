/*
 * Tensor_Initializer.h
 *
 *  Created on: Mar 3, 2018
 *      Author: joseph
 */

#ifndef TENSOR_INITIALIZER_H_
#define TENSOR_INITIALIZER_H_

#include "Tensor_Core.h"
#include "Tensor_Core_Slice.h"
#include "Tensor_Core_Scalar.h"
#include "Determiners.h"

#include "Tensor_Operations.h"
#include "../../BC_Expressions/Expression_Binary_Pointwise.h"

namespace BC {

//-------------------------------------SPECIALIZATION FOR EXPRESSION TENSORS OR TENSORS OF NON_OWNERSHIP/CREATION-------------------------------------//
template<class functor_type, int rank, class Mathlib, class expression_tensor = void>
class TensorInitializer {

	using self 			= TensorInitializer<functor_type, rank, Mathlib, expression_tensor>;
//	using functor_type 	= _functor<derived>;
//	using Mathlib 		= _mathlib<derived>;
//	using scal			= _scalar<derived>;

public:

	functor_type black_cat_array;

	TensorInitializer(		 self&& tensor) : black_cat_array(tensor.black_cat_array){}
	TensorInitializer(const  self&  tensor) : black_cat_array(tensor.black_cat_array){}
	template<class... params>
	TensorInitializer(const  params&... p) : black_cat_array(p...) {}
};
//-------------------------------------SPECIALIZATION FOR TENSORS THAT CONTROL / DELETE THEIR ARRAY-------------------------------------//
template<class functor_type, class Mathlib, int rank>
class TensorInitializer<functor_type, rank, Mathlib, std::enable_if_t<MTF::isCorePure<functor_type>::conditional>> {
	static constexpr int RANK = rank;
	using self 			= TensorInitializer<functor_type, rank, Mathlib, std::enable_if_t<MTF::isCorePure<functor_type>::conditional>>;

//	using self 			= TensorInitializer<derived, std::enable_if_t<MTF::isCorePure<t>::conditional>>;
//
//	using functor_type 	= _functor<derived>;
//	using Mathlib 		= _mathlib<derived>;
//	using scal			= _scalar<derived>;
	using _shape 		= std::vector<int>;
protected:
	functor_type black_cat_array;
private:
	auto& asBase() 			   { return static_cast<	  self&>(*this); }
	const auto& asBase() const { return static_cast<const self&>(*this); }

public:

	TensorInitializer(self&& tensor)
	{
		black_cat_array.is = tensor.black_cat_array.is;
		black_cat_array.os = tensor.black_cat_array.os;
		black_cat_array.array = tensor.black_cat_array.array;

		tensor.black_cat_array.is 		= nullptr;
		tensor.black_cat_array.os 		= nullptr;
		tensor.black_cat_array.array 	= nullptr;
	}

	TensorInitializer(const self& tensor) : black_cat_array(tensor.innerShape()){
		Mathlib::copy(asBase().data(), tensor.data(), tensor.size());
	}
	TensorInitializer(_shape dimensions): black_cat_array(dimensions){}

	TensorInitializer() { static_assert(RANK == 0, "DEFAULT CONSTRUCTOR ONLY AVAILABLE TO SCALARS"); }

	template<class T>
	using derived_alt = typename shell_of<self>::template  type<T, Mathlib>;

	template<class U>
	TensorInitializer(const derived_alt<U>&  tensor)
		: black_cat_array(tensor.innerShape()) {
		Mathlib::copy(this->asBase().data(), tensor.data(), this->asBase().size());
	}

	~TensorInitializer() {
		if (black_cat_array.array)
			Mathlib::destroy (black_cat_array.array);
		if (black_cat_array.is)
			Mathlib::destroy (black_cat_array.is);
		if (black_cat_array.os)
			Mathlib::destroy (black_cat_array.os);
	}
};

}


#endif /* TENSOR_INITIALIZER_H_ */
