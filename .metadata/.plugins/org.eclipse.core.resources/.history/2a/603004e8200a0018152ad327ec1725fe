/*
 * BlackCat_Tuple.h
 *
 *  Created on: Feb 4, 2018
 *      Author: joseph
 */

#ifndef BLACKCAT_TUPLE_H_
#define BLACKCAT_TUPLE_H_


/*
 * Thanks CUDA for not supporting make_tuple, so I make my own tuple here I guess...
 */

namespace BC {
	template<int A, class F, class... set> struct typeFromIndex { using type = typename typeFromIndex<(A - 1 > 0 ? A - 1 : 0), set...>::type; };
	template<	    class F, class... set> struct typeFromIndex<0, F, set...> { using type = F; };

	template<int A, template<class...> class From, class... set> struct typeFromIndex<A, From<set...>>
	{ using type = typename typeFromIndex<A, set...>::type; };
	template<	   template<class...> class From, class... set> struct typeFromIndex<0, From<set...>>
	{ using type = typename typeFromIndex<0, set...>::type; };



	template<class...> struct tuple_array;
	template<class T> struct tuple_array<T> {
		T data;
		static constexpr int bit_sz = sizeof(data);
		tuple_array(T t) : data(t) {}
	};
	template<class T, class... set> struct tuple_array<T, set...> : tuple_array<set...> {
		T data;
		static constexpr int bit_sz = sizeof(data);
		static constexpr int bit_index(int i) { return i == 0 ? 0 : bit_sz + tuple_array<set...>::bit_sz; }

		tuple_array(T t, set... s) : data(t), tuple_array<set...>(s...) {}
		template<int i> auto& get() { return static_cast<typename typeFromIndex<i, T, set...>::type*>(static_cast<void*>(this) + bit_index(i)); };
	};

	template<class... set>
	struct Tuple {


		tuple_array<set...> array;
		Tuple(set... s) : array(s...) {};

	};
}
//	template<class...> struct BC_tuple;
//

//
//	template<int N, class... set> struct GETTER;
//
//
//	template<class front, class... set> struct GETTER<0, front, set...>{
//		template<class T>
//		static typename T::type& get(T& t) {
//			return t.data;
//		}
//	};
//	template<int N, class front, class... set> struct GETTER<N, front, set...>{
//		template<class T>
//		static auto& get(T& t) {
//			return GETTER<(N - 1 > 0 ? N - 1 : 0), set...>::get(static_cast<typename T::parent_class&>(t));
//		}
//	};
//	template<class front> struct BC_tuple<front> {
//		using type = front;
//		using parent_class = BC_tuple<front>;
//		BC_tuple<front>& parent() { return *this; }
//		front data;
//		BC_tuple(front f) : data(f) {}
//		template<int n> auto& get() {
//			static_assert(n == 0, "get_index exceeds tuple size");
//			return data;
//		}
//
//	};
//
//
//
//	template<class front, class... set> struct BC_tuple<front, set...>  :  BC_tuple<set...> {
//	using parent_class = BC_tuple<set...>;
//	using type = front;
//	front data;
//
//	BC_tuple(front F, set... s) : data(F), BC_tuple<set...>(s...) {}
//	BC_tuple<set...>& parent() { return static_cast<parent_class&>(*this); }
//
//	template<int n> auto& get() {
//		return GETTER<n,front, set...>::get(*this);
////		if (n == 0) {
////			return this->data;
////		} else {
////			return parent_class::get<(n - 1 > 0 ? n - 1 : 0)>();
////		}
//
//	}


#endif /* BLACKCAT_TUPLE_H_ */
