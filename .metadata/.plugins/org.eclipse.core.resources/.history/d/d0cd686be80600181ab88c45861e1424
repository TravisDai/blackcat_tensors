


/*
 * Shape.h
 *
 *  Created on: Jan 18, 2018
 *      Author: joseph
 */

#ifndef SHAPE_H_
#define SHAPE_H_

#include <vector>



//struct inner_shape {
//
//	static constexpr int COMPILE_TIME_ROWS() { return 0; }
//	static constexpr int COMPILE_TIME_COLS() { return 0; }
//
//
//	bool parent;
//	int sz = 1;
//	int *is = &sz;
//	int order = 0 ;
//	int rank() const { return order; }
//	int size() const { return sz; }
//	int rows() const { return order > 0  ? is[0] : 1; }
//	int cols() const { return order > 1  ? is[1] : 1; }
//	int dimension(int i) const { return order > i  ? is[i] : 1; }
//
//	const auto InnerShape() const { return is; }
//
//	inner_shape() : parent(false){}
//	inner_shape(std::initializer_list<int> sh) : order(sh.size()), parent(true) {
//		sz = 1;
//		is = new int[order];
//		for (int i = 0; i < order; ++i) {
//			sz *= sh.begin()[i];
//			is[i] =  sh.begin()[i];
//		}
//	}
//	inner_shape(_shape sh) : order(sh.size()), parent(true) {
//		sz = 1;
//		is = new int[order];
//		for (int i = 0; i < order; ++i) {
//			sz *= sh.begin()[i];
//			is[i] =  sh.begin()[i];
//		}
//	}
//	bool inner_shape_override(_shape sh) {
//		if (!parent) {
//			std::cout << " cannot alter non-parent tensor -- must create a deep copy --" << std::endl;
//			throw std::invalid_argument("Override Nested Shape Illegal");
////			return false;
//		} else {
//			delete[] is;
//
//			is = new int[order];
//			for (int i = 0; i < order; ++i) {
//				sz *= sh.begin()[i];
//				is[i] =  sh.begin()[i];
//			}
//		}
//		return true;
//	}
//
//
//	inner_shape(const inner_shape&  sh, _expression) : parent(false), sz(sh.sz), order(sh.order), is(sh.is) {}
//	inner_shape(const inner_shape&  sh, _accessor  ) : parent(false), sz(sh.sz / sh.is[sh.order - 1]), order(sh.order - 1), is(sh.is) {}
//	~inner_shape() {
//		if (parent) {
//			delete[] is;
//		}
//	}
//
//	void printDimensions() const {
//		for (int i = 0; i < order; ++i) {
//			std::cout << "[" << is[i] << "]";
//		}
//		std::cout << std::endl;
//	}
//};
//
//
//
//struct outer_shape {
//
//	static constexpr int COMPILE_TIME_LD_ROWS() { return 0; }
//	static constexpr int COMPILE_TIME_LD_COLS() { return 0; }
//
//	int one = 1;
//	bool parent = false;
//	int * is = &one;
//	int order = 0;
//
//	int LD_rows() const { return order > 0  ? is[0] : 1; }
//	int LD_cols() const { return order > 1  ? is[1] : 1; }
//	int LD_dimension(int i) const { return order > i  ? is[i] : 1; }
//
//	const auto OuterShape() const { return is; }
//	outer_shape() : parent(false) {}
//	outer_shape(std::initializer_list<int> sh) : order(sh.size()), parent(true) {
//		is = new int[order];
//		for (int i = 0; i < order; ++i) {
//			is[i] =  sh.begin()[i];
//		}
//	}
//	outer_shape(std::vector<int> sh) : order(sh.size()), parent(true) {
//		is = new int[order];
//		for (int i = 0; i < order; ++i) {
//			is[i] =  sh.begin()[i];
//		}
//	}
//	bool outer_shape_override(_shape sh) {
//		if (!parent) {
//			std::cout << "attemping to override  non parent outershape. -- Create a deep copy" << std::endl;
//			throw std::invalid_argument("error");
////			return false;
//		}
//
//		delete[] is;
//		is = new int[order];
//		for (int i = 0; i < order; ++i) {
//			is[i] =  sh.begin()[i];
//		}
//		return true;
//	}
//	outer_shape(const outer_shape& sh) : is(sh.is), parent(false), order(sh.order) {}
//	outer_shape(const outer_shape& sh, _expression) : is(sh.is), parent(false), order(sh.order) {}
//	outer_shape(const outer_shape& sh, _accessor  ) : is(sh.is), parent(false), order(sh.order) {}
//	~outer_shape() {
//		if (parent) {
//			delete[] is;
//		}
//	}
//};

namespace BC {

struct Shape { //: private INNER, private OUTER {
public:
	static constexpr int COMPILE_TIME_ROWS() { return 0; }
	static constexpr int COMPILE_TIME_COLS() { return 0; }

	_shape is;
	_shape os;

	int sz;
	int order;

	int rank() const { return order; }
	int size() const { return sz;    }
	int rows() const { return order > 0 ? is[0] : 1; }
	int cols() const { return order > 1 ? is[1] : 1; }
	int dimension(int i) const { return order > i ? is[i] : 1; }
	void printDimensions() const { for (int i = 0; i < order; ++i) { std::cout << "["<< is[i] << "]"; } std::cout << std::endl; }

	int LD_rows() const { return order > 1 ? os[0] : 1; }
	int LD_cols() const { return order > 2 ? os[1] : 1; }
	int LDdimension(int i) const { return order > i + 1 ? os[i] : 1; }

	bool array_ownership;

	auto expression_packet() const  { return shape_packet<_reference>(is, os, order, sz); }
	auto shape_copy_packet() const 	{ return shape_packet<_reference>(is, os, order, sz); }

	auto accessor_packet() const    { return shape_packet<dual<_value, _reference>>(is, os, order - 1, sz/is[order - 1]); }
	auto transpose_packet() const   { return shape_packet<dual<_value, _reference>>({this->cols(), this->rows()}, os, 2, sz); }
	auto dotproduct_packet(int eval_order, const Shape& sh) const {

		return eval_order == 1 ?
				shape_packet<_value>({this->rows()}) :
				shape_packet<_value>({this->rows(), sh.cols()});
	}

	auto subAccessor_packet(std::vector<int> is) const  { return shape_packet<_value>(is, os, order, sz); }

	const Shape& asShape() const { return *this; }
	void ChangeShapeOwnership(bool swap = false) {
		array_ownership = swap;
	}

	_shape init(int a, int b = -1) const {
		if (b == -1) {
			return {a};
		} else {
			return { a , b};
		}
	}

//	template<class pass_type>
//	Shape(shape_packet<pass_type> exp) : INNER(exp.is, pass_type()), OUTER(exp.os, pass_type()) {}
//	Shape(shape_packet<_transpose> exp) : INNER(exp.order == 1 ? init(exp.col) : init(exp.row, exp.col)), //1== Vector, else Matrix order//
//											OUTER(exp.os) {
//	}
//	Shape(shape_packet<_dotproduct> exp) : INNER(exp.order == 1 ? init(exp.row) : init(exp.row, exp.col)), //1== Vector, else Matrix order//
//												OUTER(exp.order == 1 ? init(exp.row) : init(exp.row, exp.col)) {}
//
//	Shape(shape_packet<_subAccessor> exp) : INNER(exp.is), OUTER(exp.os) {}
//
//
//	Shape(shape_packet<_generic> exp) : INNER(exp.shape), OUTER(exp.shape) {}
//	bool resetShape(shape_packet<_generic> exp =  shape_packet<_generic>(_shape(0))) {
//		return this->inner_shape_override(exp.shape) && this->outer_shape_override(exp.shape);
//	}

};

}

#endif /* SHAPE_H_ */



