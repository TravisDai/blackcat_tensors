
#ifndef BLACKCAT_TUPLE
#define BLACKCAT_TUPLE

#include "BlackCat_Tensors.h"
#include "BlackCat_TensorFunctions.cu"

namespace BC {
using namespace NN_Abreviated_Functions;

template<class> struct InputLayer;
template<class> struct OutputLayer;

struct BASE;

using ml = CPU;

using vec = Vector<double>;
using mat = Matrix<double>;
using fp_type = double;

template<class T, class ML = ml> using mat_expr = Matrix<T, ML>;
template<class T, class ML = ml> using vec_expr = Vector<T, ML>;

template<class derived, template<class> class...> struct LayerChain;

template<class>
struct OUTPUT_LAYER;

	//TAIL
	template<class derived>
	struct LayerChain<derived, OutputLayer> {

		using p = derived;
		using me = LayerChain<derived, OutputLayer>;
		using type = OutputLayer<me>;

		type* data_;
		bool hasNext() const { return false; }

		const auto& tail() const { return data_; }
		auto& tail() { return  data_; }

		const auto& head() const { return prev().head(); }
			  auto& head()  { return prev().head(); }

			  const auto& next() const { throw std::invalid_argument("no next end of chain"); }
			  auto& next() { throw std::invalid_argument("no next end of chain"); }

		const auto& prev() const { return static_cast<p&>(*this).data(); }
			  auto& prev() { return static_cast<p&>(*this).data(); }
	private:

		const auto& data() const { return *data_; }
			  auto& data()  { return *data_; }
	};

	//BODY
	template<class derived, template<class> class front, template<class> class... lst>
	struct LayerChain<derived, front, lst...> : LayerChain<LayerChain<derived, front, lst...>, lst...> {

		using p = derived;
		using parent = LayerChain<LayerChain<derived, front, lst...>, lst...>;
		using n = typename LayerChain<LayerChain<derived, front, lst...>, lst...>::type;
		using me = LayerChain<derived, front, lst...>;
		using type = front<me>;

		type* data_;

		bool hasNext() const { return true; }


		const auto& tail() const { return next().tail(); }
		const auto& head() const { return prev().head(); }

		auto& tail() { return next().tail(); }
		auto& head() { return prev().head(); }

		auto& prev()  { return static_cast<p&>(*this).data(); }
		const auto& prev() const { return static_cast<p&>(*this).data(); }

		auto& next()    { return static_cast<n&>(*this).data(); }
		const auto& next() const { return static_cast<n&>(*this).data(); }
	private:

		const auto& data() const { return *data_; }
		 auto& data()  { return *data_; }

	};


	//HEAD
	template<template<class> class... lst>
	struct LayerChain<BASE, InputLayer, lst...> : LayerChain<LayerChain<BASE, InputLayer, lst...>, lst...> {

		using n = typename LayerChain<LayerChain<BASE, InputLayer, lst...>, lst...>::type;
		using parent = LayerChain<LayerChain<BASE, InputLayer, lst...>, lst...>;
		using me = LayerChain<BASE, InputLayer, lst...>;
		using type = InputLayer<me>;

		type* data_;

		bool hasNext() const { return true; }


		const auto& tail() const { return next().tail(); }
		const auto& head() const { return *data_; }
			  auto& tail() 		 { return next().tail(); }
			  auto& head()  	 { return *data_; }

			  auto& next()  	 { return static_cast<n&>(*this).data(); }
		const auto& next() const { return static_cast<n&>(*this).data(); }

	private:
		const auto& data() const { return *data_; }
		 	  auto& data()  	 { return *data_; }
	};

	template< class head, class... integers>
	void initializerTail(head net, integers... params) {
		Net.data_ = new decltype(net.data_)(params...);

	}

	template< class head, class... integers>
	void initializer(head net, int x, int y, integers... params) {
		Net.data_ = new decltype(net.data_)(x, y);

		if (sizeof...(params) > 1)
		initializer(net.next(), y, params...);
		else
			initializerTail(Next.next(), params...);
	}
	template< class head, class... integers>
	void initializerHead(head net, int x, integers... params) {

		net.data_ = new decltype(net.data_)(x);
		initializer(net.next(), x, params...);
	}


	template<template<class> class... layers, class... integers>
	auto generateNetwork(integers... structure) {
		auto net = LayerChain<BASE, InputLayer, layers..., OutputLayer>();
		initializerHead(net, structure...);

		return net;
	}


}
#endif
