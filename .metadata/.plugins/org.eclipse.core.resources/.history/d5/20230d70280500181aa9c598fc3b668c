/*
 * Tensor_Base.h
 *
 *  Created on: Jan 6, 2018
 *      Author: joseph
 */

#ifndef TENSOR_BASE_H_
#define TENSOR_BASE_H_


#include "Implementation_Core/Tensor_IdentityClasses.h"
#include "Implementation_Core/Tensor_Operations.h"
#include "Implementation_Core/Tensor_Utility.h"
#include "Implementation_Core/Shape.h"

#include "../BC_MathLibraries/Mathematics_CPU.h"
#include "../BC_MathLibraries/Mathematics_GPU.cu"


namespace BC {


template<class T, class derived, class Mathlib >
class TensorBase :
				public Tensor_Math_Core<T, derived, Mathlib>,
				public Tensor_Utility  <T, derived, Mathlib, MTF::isPrimitive<T>::conditional>,

				public Shape<inner_shape, outer_shape>
{

protected:
	struct DISABLE;

	using shape = Shape<inner_shape, outer_shape>;
	bool OWNERSHIP = MTF::isPrimitive<T>::conditional && Shape<inner_shape, outer_shape>::array_ownership;

	using math_parent  = Tensor_Math_Core<T, derived, Mathlib>;
	using array_parent = Tensor_Math_Core<T, derived, Mathlib>;
	using shape_parent = Shape<inner_shape, outer_shape>;

	using functor_type 			= typename Tensor_Math_Core<T, derived, Mathlib>::functor_type;
	using subAccess_int 		= typename MTF::IF_ELSE<MTF::isPrimitive<T>::conditional, int, DISABLE>::type;
	using force_evaluation_int 	= typename MTF::IF_NOT_ELSE<MTF::isPrimitive<T>::conditional, int, DISABLE>::type;



public:

	functor_type array;
	auto operator [] (force_evaluation_int i) { return this->data()[i]; }

	template<class pass_type, class... params>
	TensorBase(const shape_packet<pass_type>& exp, const params&... p) : shape(exp), array(p...) {}

//	template<class pass_type>
//	TensorBase(const shape_packet<pass_type>& exp) : shape(exp) {
//		Mathlib::initialize(this->asBase().data(), this->size());
//	}
	TensorBase(derived&& tensor) : shape(tensor.expression_packet()), array(tensor.data()) {
			tensor.changeOwnership(false);
			this->changeOwnership(true);
	}
	TensorBase(const derived& tensor) : shape(tensor.shape_copy_packet()){
//		Mathlib::initialize(this->asBase().data(), this->size());
//			Mathlib::copy(this->data(), tensor.data(), this->size());
	}

	template<class U, class D> TensorBase(const TensorBase<U, D, Mathlib>& tensor) : shape(mat.shape_copy_packet()) {
		Mathlib::initialize(this->asBase().data(), this->size());
		Mathlib::copy(this->data(), mat.data(), this->size());
	}



	TensorBase(const T* param) :  array(const_cast<T*>(param)) {}
	TensorBase() : Shape({0}) {
		Mathlib::initialize(this->asBase().data(), this->size());
	}
	TensorBase(std::initializer_list<int> dimensions) : Shape<inner_shape, outer_shape>(dimensions) {
		Mathlib::initialize(this->asBase().data(), this->size());
	}

	template<class... params>
	TensorBase(std::initializer_list<int> dimensions, params... p) : shape_parent(dimensions), array(p...) {}


	template<class U, class D>
	derived& operator = (const TensorBase<U, D, Mathlib>& param) {
		this->assert_same_size(param);
		Mathlib::copy(this->data(), param.data(), this->size());
		return this->asBase();
	}

	void changeOwnership(bool change = false) {
		ChangeShapeOwnership(change);
		this->OWNERSHIP = false;
	}

	~TensorBase() {
		if (OWNERSHIP) {
			Mathlib::destroy(array);
		}
	}

};
}



#endif /* TENSOR_BASE_H_ */

