/*
 * Expression_Binary_Dotproduct.cu
 *
 *  Created on: Jan 9, 2018
 *      Author: joseph
 */
#ifdef  __CUDACC__
#ifndef EXPRESSION_BINARY_DOTPRODUCT_CU_
#define EXPRESSION_BINARY_DOTPRODUCT_CU_

#include "Expression_Binary_Dotproduct_impl.cu"
#include "Expression_Base.cu"
#include "BlackCat_Internal_Definitions.h"
#include "../BC_MetaTemplateFunctions/Adhoc.h"
#include <iostream>
#include <memory>
#include <vector>

namespace BC {

/*
 * a = M x K
 * b = K x N
 * c = M x N
 */
//det_Eval

template<class T, class lv, class rv, class Mathlib>
struct binary_expression_dotproduct : expression<T, binary_expression_dotproduct<T, lv, rv, Mathlib>> {

	using scalar_type = typename MTF::determine_scalar<T>::type;

	static constexpr bool transA = det_eval<lv>::transposed;
	static constexpr bool transB = det_eval<rv>::transposed;
	static constexpr bool lv_scalar = det_eval<lv>::scalar;
	static constexpr bool rv_scalar = det_eval<rv>::scalar;
	static constexpr bool lv_eval = det_eval<lv>::evaluate;
	static constexpr bool rv_eval = det_eval<rv>::evaluate;

	const int mnk[3] =  { left.rows(), right.cols(), left.cols() };

	const int LDA = left.LD_rows();
	const int LDB = right.LD_rows();
	const int LDC = mnk[0];

	const int lv_size = mnk[0] * mnk[2];
	const int rv_size = mnk[1] * mnk[2];
	const int eval_size = mnk[0] * mnk[1] ;

	lv left;
	rv right;
	_scalar<T>* array_ptr;
//	std::shared_ptr<scalar_type> array;
	int* reference_count = Mathlib::unified_initialize(reference_count, 1);

	binary_expression_dotproduct(lv left, rv right) : left(left), right(right), LDA(left.LD_rows()), LDB(right.LD_rows()) {
		Mathlib::initialize(array_ptr,eval_size);
		eval();
	}

	__BCinline__ binary_expression_dotproduct(const binary_expression_dotproduct& bed) :
			LDA(bed.LDA), LDB(bed.LDB), LDC(bed.LDC),
			lv_size(bed.lv_size), rv_size(bed.rv_size),
			eval_size(bed.eval_size),
			left(bed.left),
			right(bed.right),
			array_ptr(bed.array_ptr)

	{
			*reference_count++;
	}

	__BCinline__ binary_expression_dotproduct(binary_expression_dotproduct&& bed) :
			mnk(bed.mnk),
			LDA(bed.LDA), LDB(bed.LDB), LDC(bed.LDC),
			lv_size(bed.lv_size), rv_size(bed.rv_size),
			eval_size(bed.eval_size),
			left(bed.left),
			right(bed.right),
			array_ptr(bed.array_ptr)

	{
			*reference_count++;
	}

	__BCinline__  int size() const { return eval_size;}
	__BCinline__  int rows() const { return mnk[0];}
	__BCinline__  int cols() const { return mnk[1];}
	__BCinline__  int rank() const { return right.rank(); }
	__BCinline__  int LD_rows() const { return mnk[0]; }
	__BCinline__  int LD_cols() const { return eval_size; }
	__BCinline__  int dimension(int i)		const { return i== 0 ? mnk[0] : i == 1 ? mnk[1] : 1; }
	__BCinline__  const auto innerShape() 	const { return mnk; }
	__BCinline__  const auto outerShape() 	const { return mnk; }

	__attribute__((always_inline))  __BCinline__  const T operator [](int index) const { return array_ptr[index]; }
	__attribute__((always_inline))  __BCinline__  	    T operator [](int index) 	   { return array_ptr[index]; }

	 void printDimensions() 		const { std::cout<<"[" << mnk[0] << "][" << mnk[1]  <<"]" << std::endl; }
	 void printLDDimensions()	const { std::cout<<"[" << mnk[0] << "][" <<eval_size  <<"]" << std::endl; }

	void eval() {

		T* A = nullptr;
		T* B = nullptr;
		T* alpha = nullptr;
		T* alpha2 = nullptr;

		if (lv_eval) {
			Mathlib::initialize(A, lv_size);
			Mathlib::copy(A, left, lv_size);
		} else {
			A = det_eval<lv>::getArray(left);
		}
		if (rv_eval) {
			Mathlib::initialize(B, rv_size);
			Mathlib::copy(B, right, rv_size);
		} else {
			B = det_eval<rv>::getArray(right);
		}
			alpha = det_eval<lv>::getScalar(left);		//nullptr if !lv_scalar
			alpha2 = det_eval<rv>::getScalar(right);	//nullptr if !rv_scalar


			//if scalars on both sides we need to convert them into a single scalar (for it to work with blas)
		if (lv_scalar && rv_scalar){
			T* tmp;
			Mathlib::initialize(tmp, 1);
			Mathlib::scalarMul(tmp, alpha, alpha2);
			Mathlib::MatrixMul(transA, transB, A, B, array_ptr, mnk[0], mnk[1], mnk[2], tmp, nullptr, LDA, LDB, LDC);
			Mathlib::destroy(tmp);

		} else if (rv_scalar)
			 Mathlib::MatrixMul(transA, transB, A, B, array_ptr, mnk[0], mnk[1], mnk[2], alpha2, nullptr, LDA, LDB, LDC);
		 else if (lv_scalar)
			 Mathlib::MatrixMul(transA, transB, A, B, array_ptr, mnk[0], mnk[1], mnk[2], alpha, nullptr, LDA, LDB, LDC);
		 else
			 Mathlib::MatrixMul(transA, transB, A, B, array_ptr, mnk[0], mnk[1], mnk[2], nullptr, nullptr, LDA, LDB, LDC);

		if (lv_eval)
			Mathlib::destroy(A);
		if (rv_eval)
			Mathlib::destroy(B);

	}

	};
}

#endif /* EXPRESSION_BINARY_DOTPRODUCT_CU_ */
#endif


//				Some printouts for debugging
//
//		std::cout << "dotproduct stats --------------------------------------------------------------------------" << std::endl;
//				std::cout << " m n k = " << M << "  "<< N << " " << K << std::endl;
//
//				if (lv_needs_to_be_evaluated) {
//					if (self_eval<lv>::conditioanl) {
//						std::cout << " lv self eval " << std::endl;
//					}
//					std::cout << " lv was evaluated " << std::endl;
//				}
//				if (rv_needs_to_be_evaluated) {
//					if (self_eval<rv>::conditioanl) {
//						std::cout << " rv self eval " << std::endl;
//					}
//					std::cout << " lv was evaluated " << std::endl;
//				}
//				if (transA) {
//					std::cout << " A - fast trans " << std::endl;
//				}
//				if (transB) {
//					std::cout << " B - fast trans " << std::endl;
//				}
//				if (evaluate<lv>::scalar) {
//					std::cout << " lv scalar detected " << std::endl;
//				}
//				if (evaluate<rv>::scalar) {
//					std::cout << " rv scalar detected " << std::endl;
//				}
//				if (scal_A && scal_B)
//				std::cout << "scalars = " << *scal_A <<  " " << *scal_B << std::endl;
//				std::cout << " --------------------------------------------------------------------------" << std::endl;


