/*

 * BC_Expression_Base.h
 *
 *  Created on: Dec 11, 2017
 *      Author: joseph
 */

#ifdef  __CUDACC__
#ifndef EXPRESSION_BASE_H_
#define EXPRESSION_BASE_H_
#include <cuda.h>
#include "BlackCat_Internal_Definitions.h"
#include <iostream>
namespace BC {

template<class T, class derived>
struct expression {
	using type = derived;
	using scalar_type = T;
private:

	template<class ret = void>
	static ret shadowFailure(std::string method, ret = int(0)) {
		std::cout << "SHADOW METHOD FAILURE OF REQUIRED METHOD - ENLIGHTENED METHOD: " << method << " -- OVERRIDE THIS METHOD" << std::endl;
		throw std::invalid_argument("MANDATORY METHOD - NOT SHADOWED ");
	}
	static int r0() { return 0; }

		  derived& asDerived() 		 { return static_cast<	    derived&>(*this); }
	const derived& asDerived() const { return static_cast<const derived&>(*this); }

public:


	int rank() const 	{ return shadowFailure<int>("int rank() const"); }
	int size() const 	{ return shadowFailure<int>("int size() const"); }
	int rows() const 	{ return shadowFailure<int>("int rows() const"); }
	int cols() const 	{ return shadowFailure<int>("int cols() const"); }
	int LD_rows() const { return shadowFailure<int>("int LD_rows() const"); }
	int LD_cols() const { return shadowFailure<int>("int LD_cols() const");}

	int dimension(int i)		const { return shadowFailure<int>("int dimension(int) const");} }
	void printDimensions() 		const { asDerived().printDimensions();   }
	void printLDDimensions()	const { asDerived().printLDDimensions(); }

	auto accessor_packet(int index) const { return asDerived().accessor_packet(index); }

	const auto InnerShape() const 			{ return asDerived().InnerShape(); }
	const auto OuterShape() const 			{ return asDerived().OuterShape(); }
};

template<class T>
auto addressOf(const T& param, int offset) {
	return param.addressOf(offset);
}
//	auto operator [] (int index) -> decltype(asDerived()[index]) { return asDerived()[index]; }
//	auto operator [] (int index) const -> decltype(asDerived()[index]) { return asDerived()[index]; }

//	int rank() const { return asDerived().rank(); }
//	int size() const { return asDerived().size(); }
//	int rows() const { return asDerived().rows(); }
//	int cols() const { return asDerived().cols(); }
//	int LD_rows() const { return asDerived().LD_rows(); }
//	int LD_cols() const { return asDerived().LD_cols(); }
//	int dimension(int i)		const { return asDerived().dimension(i);    }
//	int LD_dimension(int i) 	const { return asDerived().LD_dimension(i); }
//	void printDimensions() 		const { asDerived().printDimensions();   }
//	void printLDDimensions()	const { asDerived().printLDDimensions(); }
//
//	auto InnerShape()  const { return asDerived().InnerShape(); }
//	auto OuterShape()  const { return asDerived().OuterShape(); }
}

#endif /* EXPRESSION_BASE_H_ */
#endif
