/*
 * FeedForward.cu
 *
 *  Created on: Jan 28, 2018
 *      Author: joseph
 */

#ifndef FEEDFORWARD_CU_
#define FEEDFORWARD_CU_

#include "Layer.cu"

namespace BC {

struct FeedForward : Layer<FeedForward> {

public:
	const int INPUTS;
	const int OUTPUTS;

	mat w_gradientStorage;
	vec b_gradientStorage;

	mat w;

	vec x;
	vec y;
	vec b;

	vec dx;

	//operator == is a delayed evaluation assignment operator
	FeedForward(int inputs, int outputs) :
			INPUTS(inputs), OUTPUTS(outputs),
			w_gradientStorage(outputs, inputs),
			b_gradientStorage(outputs),
			w(outputs, inputs),
			b(outputs),
			x(inputs),
			y(outputs),
			dx(inputs) {

		w.randomize(-3, 3);
		b.randomize(-3, 3);
		w_gradientStorage.zero();
		b_gradientStorage.zero();

		w.print();
		b.print();

	}

	template<class T> auto forwardPropagation(vec_expr<T> in) {

		auto x_t = x == in; 								//creates a temporary that states evaluate x to in when appropriate
		return y == g(w * x_t + b);

	}
	template<class T> auto forwardPropagation_Express(vec_expr<T> x) const {
		return g(w * x + b);
	}

	template<class Y> Y copy (Y y) { return y; }

	template<class T> auto backPropagation(vec_expr<T> dy) {
		w_gradientStorage = w_gradientStorage - dy * x.t();
		b_gradientStorage = b_gradientStorage - dy;
		return dx == w.t() * dy % gd(x);							//** is point_wise multiply
	}

	void updateWeights() {

		std::cout << " weight update " <<std::endl;
		w += w_gradientStorage * lr;
		b += b_gradientStorage * lr;
	}
	void clearBPStorage() {
		w_gradientStorage.zero();
		b_gradientStorage.zero();
	}

};
}



#endif /* FEEDFORWARD_CU_ */
