/*
 * Shape.h
 *
 *  Created on: Jan 18, 2018
 *      Author: joseph
 */

#ifndef SHAPE_H_
#define SHAPE_H_

#include <vector>

namespace BC {
class _expression {};
class _accessor {};
class _subAccessor {};
class _transpose {};
class _dotproduct {};
class _generic {};

using _shape = std::vector<int>;

#ifndef SHAPE__H_
#define SHAPE__H_

#include <vector>

namespace BC {
class _expression {};
class _accessor {};
class _subAccessor {};
class _transpose {};
class _dotproduct {};
class _generic {};

using _shape = std::vector<int>;

class Shape {

	bool ownership = true;
	int order = is.size();
	int sz;
	_shape is;
	_shape os;

public:


	Shape(_shape is = _shape(0), _shape os = _shape(0), int order = 0, int sz = 1, bool owner = false) : ownership(owner), sz(sz) {
		if (order == -1)
			order = is.size();
		if (sz == -1) {
			if (is.size() > 0) {
				sz = is[0];
				for (int i = 1; i < order; ++i) {
					sz *= is[i];
				}
			}
		}
	}




	static constexpr int COMPILE_TIME_ROWS() { return 0; }
	static constexpr int COMPILE_TIME_COLS() { return 0; }


	int rank() const { return order; }
	int size() const { return sz;    }
	int rows() const { return order > 0 ? is[0] : 1; }
	int cols() const { return order > 1 ? is[1] : 1; }
	int dimension(int i) const { return order > i ? is[i] : 1; }
	void printDimensions() const { for (int i = 0; i < order; ++i) { std::cout << "["<< is[i] << "]"; } std::cout << std::endl; }

	int LD_rows() const { return order > 1 ? os[0] : 1; }
	int LD_cols() const { return order > 2 ? os[1] : 1; }
	int LDdimension(int i) const { return order > i + 1 ? os[i] : 1; }

	const int* InnerShape() const { return &is[0]; }

	bool array_ownership = false;

	auto expression_packet() const  { return Shape(is, os, this->order(), this->size()); }
	auto shape_copy_packet() const 	{ return Shape(is, os, this->size()); }
	auto accessor_packet() const    { return Shape(is, os, order -1 , this->size() / is[order - 1]); }
	auto transpose_packet() const   { return Shape( {this->cols(), this->rows() }); }

	auto dotproduct_packet(int eval_order, const Shape& sh) const  {
		if (eval_order == 1) {
			return _shape({this->rows()});
		} else {
			return _shape({this->rows(), cols()});
		}
	}
	auto subAccessor_packet(std::vector<int> is) const  { return shape_packet(is, os); }

	const Shape& asShape() const { return *this; }
	void ChangeShapeOwnership(bool swap = false) {
		array_ownership = false;
	}
	void resetShape(_shape is_) {
		re_init(is_);
	}
};

}
#endif /* SHAPE_H_ */
