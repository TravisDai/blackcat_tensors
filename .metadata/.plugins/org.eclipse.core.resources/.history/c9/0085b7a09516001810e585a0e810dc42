/*
 * TensorN.h
 *
 *  Created on: Feb 20, 2018
 *      Author: joseph
 */

#ifndef TENSORN_H_
#define TENSORN_H_

namespace BC {

template<class T, int rank, class Mathlib>
class Tensor : public TensorBase<T, Matrix<T, Mathlib>, Mathlib, Rank<2>> {

	template<class,class>
	friend class Vector;

	using parent_class = TensorBase<T, Matrix<T, Mathlib>, Mathlib, Rank<2>>;

public:
	using scalar = T;
	using parent_class::operator=;
	using accessor = typename parent_class::accessor;
	static constexpr int RANK() { return 2; }

	Tensor() {}
	Tensor(const Tensor&  v) : parent_class(v) {}
	Tensor(		 Tensor&& v) : parent_class(v) {}
	Tensor(const Tensor&& v) : parent_class(v) {}
	Tensor(int rows, int cols = 1) : parent_class(std::vector<int> {rows, cols}) {}

	template<class U, int r>  Tensor(const Tensor<U, r, Mathlib>&  t) : parent_class(t) {}
	template<class U, int r>  Tensor(	   Tensor<U, r, Mathlib>&& t) : parent_class(t) {}
	template<class... params> Tensor(const params&... p) : parent_class(p...) {}

	Tensor& operator =(const Tensor& t)  { return parent_class::operator=(t); }
	Tensor& operator =(const Tensor&& t) { return parent_class::operator=(t); }
	Tensor& operator =(	     Tensor&& t) { return parent_class::operator=(t); }
	template<class U, int r>
	Tensor& operator = (const Tensor<U, r, Mathlib>& t) { return parent_class::operator=(t); }

	Tensor(std::vector<T> sh) : parent_class(sh) {}
	Tensor<accessor, Mathlib> operator [] (int index) { return Vector<accessor, Mathlib>(this->accessor_packet(index)); }
	const Tensor<accessor, Mathlib> operator [] (int index) const { return Vector<accessor, Mathlib>(this->accessor_packet(index)); }

	const Tensor<unary_expression_transpose<typename MTF::determine_scalar<T>::type, typename parent_class::functor_type>, Mathlib> t() const {
		return Tensor<unary_expression_transpose<typename MTF::determine_scalar<T>::type, typename parent_class::functor_type>, Mathlib>(this->data());
	}



};


}




#endif /* TENSORN_H_ */
