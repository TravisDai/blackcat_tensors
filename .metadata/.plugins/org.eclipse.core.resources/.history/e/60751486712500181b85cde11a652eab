#include <omp.h>
#include <iostream>
#include "cblas.h"
#include <cmath>
#include <iostream>
#include <string>

#include <omp.h>
#include "math.h"
#include "time.h"
#include <omp.h>

//blas
static void MatrixMul(bool transA, bool transB, const double* A, const double* B, double* C, int m, int n, int k, const double* scalarA = nullptr, const double* scalarB = nullptr,
		int lda = 0, int ldb = 0, int ldc = 0) {

	auto TRANS_A = transA ? CblasTrans : CblasNoTrans;
	auto TRANS_B = transB ? CblasTrans : CblasNoTrans;

	if (lda == 0)
		lda = m;
	if (ldb == 0)
		ldb = n;
	if (ldc == 0)
		ldc = m;

	const double beta = scalarB ? *scalarB : 0.0;
	const double alpha = scalarA ? *scalarA : 1.0;
	cblas_dgemm(CblasColMajor, TRANS_A, TRANS_B, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);
}

static void MatrixMulMe(bool transA, bool transB, const double* A, const double* B, double* C, int m, int n, int k, const double* scalarA = nullptr, const double* scalarB = nullptr,
		int lda = 0, int ldb = 0, int ldc = 0) {

	if (lda == 0)
		lda = m;
	if (ldb == 0)
		ldb = n;
	if (ldc == 0)
		ldc = m;

	const double beta = scalarB ? *scalarB : 0.0;
	const double alpha = scalarA ? *scalarA : 1.0;

	/*
	 * a = M x K
	 * b = K x N
	 * c = M x N
	 */
	for (int _n = 0, c_base = 0, b_base = 0; _n < n;
			++_n, c_base += ldc, b_base += ldb) {
		for (int _k = 0, a_base = 0; _k < k;
				++_k, a_base += lda) {
			for (int _m = 0; _m < m; ++_m) {
				C[c_base + _m] += A[a_base + _m] * B[b_base + _k];

			}
		}
	}
}

static void MatrixMulPartitioned(bool transA, bool transB, const double* A, const double* B, double* C, int m, int n, int k, const double* scalarA = nullptr, const double* scalarB = nullptr,
		int lda = 0, int ldb = 0, int ldc = 0) {

	if (lda == 0)
		lda = m;
	if (ldb == 0)
		ldb = n;
	if (ldc == 0)
		ldc = m;

	const double beta = scalarB ? *scalarB : 0.0;
	const double alpha = scalarA ? *scalarA : 1.0;

	/*
	 * a = M x K
	 * b = K x N
	 * c = M x N
	 */
	for (int _n = 0, c_base = 0, b_base = 0; _n < n;
			++_n, c_base += ldc, b_base += ldb) {
		for (int _k = 0, a_base = 0; _k < k;
				++_k, a_base += lda) {
			for (int _m = 0; _m < m; ++_m) {
				C[c_base + _m] += A[a_base + _m] * B[b_base + _k];

			}
		}
	}
}


void testSpeed(int size, int reps) {

	double* a = new double[size * size];
	double* b = new double[size * size];
	double* c = new double[size * size];

	for (int i = 0; i < size*size; ++i) {
		b[i] = i;
		a[i] = i;
	}

	float t = omp_get_wtime();
	for (int iter = 0; iter < reps; ++iter) {
		MatrixMul(false, false, a, b, c, size, size, size);
	}
	t = omp_get_wtime() - t;


	float t2 = omp_get_wtime();

	for (int iter = 0; iter < reps; ++iter) {
		MatrixMulMe(false, false, a, b, c, size, size, size);
	}
	t2 = omp_get_wtime() - t2;

	std::cout.precision(8);
	std::cout << "BLAS: sz = " << size << "  time: " << t  << "   ||   " << "ME: sz = " << size << "  time: " << t2  <<std::endl;
//
//		for (int i = 0; i < size*size; ++i) {
//			std::cout << c[i] << std::endl;
//		}

	delete[] a;
	delete[] b;
	delete[] c;

}

/*int main() {
//	for (int i = 16; i < 600; i *= 2)
//		testSpeed(i, 100);
}*/



#include <string>

const std::string myStr = "MyString";



const std::string& getString() {
	return myStr;
}


struct alpha{
	enum ba { a,b,c};

	static constexpr std::string str = "agffdsdf";


int main() {

	alpha::ba as = alpha::ba::a;

	std::cout << as << std::endl;

	std::cout << getString() << std::endl;

	const std::string& myStr = getString();

	std::cout << myStr << std::endl;
	std::cout << getString() << std::endl;

}








