/*
 * BC_Correlation.h
 *
 *  Created on: Feb 25, 2018
 *      Author: joseph
 */

#ifndef BC_CORRELATION_H_
#define BC_CORRELATION_H_

#include "../BlackCat_Tensors.h"
#include <vector>

namespace BC {
namespace corr {
struct corr_mul {
	template<class T, class U>
	__BC_gcpu__ inline __attribute__((always_inline))  T operator () (T t, U u) const {
		return t * u;
	}
};
struct axpy {
	template<class T, class U>
	__BC_gcpu__ inline __attribute__((always_inline))  T operator () (T& t, U u) const {
		return t += u;
	}
};

template<int movements>
struct cor {

template<class d0, class d1, class d2>
static auto x_corr(const TensorBase<d0>& out, const TensorBase<d1>& krnl, const TensorBase<d2>& img) {

	//if movements are greater than krnl rank we "align" the output and krnl
	if (movements > krnl.rank()) {
		for (int i = 0; i < img.rank(); ++i) {
			if (krnl.rank() == img.rank())
				x_corr(out[i], krnl[i], img[i]);
			else
				x_corr(out[i], krnl, img[i]);
		}
		return;
	}
	int positions = img.dimension(img.rank() -1) - krnl.dimension(krnl.rank() - 1) + 1;
	for (int i = 0; i < positions; ++i) {

	}
}
};
template<>
struct cor<1> {

template<class d0, class d1, class d2>
static auto x_corr(const TensorBase<d0>& out, const TensorBase<d1>& krnl, const TensorBase<d2>& img) {
	int positions = img.dimension(img.rank() -1) - krnl.dimension(krnl.rank() - 1) + 1;

	for (int i = 0; i < positions; ++i) {
		cor<0>::x_corr(out[i], krnl[i], img[i], krnl.size());
	}

}
};

template<>
struct cor<0> {
//out should be a scalar and krnl and img are both vectors of same size
template<class d0, class d1, class d2>
static auto x_corr(const TensorBase<d0>& out, const TensorBase<d1>& krnl, const TensorBase<d2>& img, int size) {

		auto expr = out.binExpr<axpy, false>(krnl.binExpr<corr_mul, false>(img));
		for (int i = 0; i < size; ++i) {
			expr[i];//iterate through the krnl to enforce evaluation
		}
}

};








};

}
}

#endif /* BC_CORRELATION_H_ */
