#include <iostream>
#include <omp.h>
#include "math.h"
#include "time.h"
#include <omp.h>
#include "../BlackCat_Tensors.h"
#include "BlackCat_TensorFunctions.cu"

using BC::Vector;
using namespace BC::NN_Functions;
template<class T>
void add(T * a, T* b, T* c, int sz) {
	for (int i = 0; i < sz; ++i) {
		a[i] = b[i] + c[i];
	}
}

template<class T>
void add(T * a, T* b, T* c, T* d, int sz) {
	for (int i = 0; i < sz; ++i) {
		a[i] = b[i] + c[i] + d[i];
	}
}


struct x2 {

	template<class l>
	auto operator ()(l left) const { return std::pow(left, 2); }
};

template<int SIZE, int repetitions>
int speedTests() {
	const int reps = repetitions;

	std::cout << "  ------------------------------------------ speed tests ------------------------------------------" << std::endl;
	std::cout << " size = " << SIZE << std::endl;
	std::cout << " Repetitions = " << reps << std::endl;

	using vec = Vector<float>;

//	using vec = Vector<float, SIZE, BC::GPU>;
	vec a(SIZE);
	vec b(SIZE);
	vec c(SIZE);
	vec d(SIZE);
	vec e(SIZE);

	b.randomize(0, 100);
	c.randomize(0, 100);
	b.randomize(0, 100);


	float t;

	t = omp_get_wtime();
	printf("\n Calculating... (BlackCat_Tensors) a = b + c + d; \n");

	for (int i = 0; i < reps; ++i) {
		a = (e == b % c + d).unExpr<x2>();
	}

	t = omp_get_wtime() - t;
	printf("It took me %f clicks (%f seconds).\n", t, ((float) t));
	std::cout << "success " << std::endl;

	t = omp_get_wtime();
	printf("\n Calculating... Generic  a = b + c && a = a + d; \n");

	for (int i = 0; i < reps; ++i) {
		e = b % c + d;
		a = e.unExpr<x2>();
	}

	t = omp_get_wtime() - t;
	printf("It took me %f clicks (%f seconds).\n", t, ((float) t));
	std::cout << "success " << std::endl;

#pragma omp barrier
	return 0;
}


