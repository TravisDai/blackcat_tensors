Black\+Cat\+\_\+\+Tensors defines two types of iterators, coefficient-\/wise and n-\/dimensional. 



\subparagraph*{Coefficient-\/\+Wise}

The coefficient-\/wise iterator returns references of the {\ttfamily value\+\_\+type} of the tensor.


\begin{DoxyCode}
\textcolor{keywordtype}{int} main() \{

    \hyperlink{classBC_1_1tensors_1_1Tensor__Base}{BC::Matrix<float>} matrix(5, 5); 

    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{float}& val : matrix) \{
      \textcolor{comment}{//do work }
    \}

    \textcolor{comment}{//identical}
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{float}& val : matrix.iter()) \{
      \textcolor{comment}{//do work }
    \}
\}
\end{DoxyCode}
 {\bfseries Warning} Tensor\textquotesingle{}s allocated via non-\/managed Cuda memory may not normally use the coefficient-\/wise iterator. (As it causes dereferencing a device pointer from the host). User\textquotesingle{}s may opt to use {\ttfamily \hyperlink{namespaceBC}{BC}} https\+://github.com/josephjaspers/\+Black\+Cat\+\_\+\+Tensors/blob/master/docs/algorithms.\+md \char`\"{}algorithms\char`\"{} to meet their needs. 



\subparagraph*{N-\/\+Dimensional}

The n-\/dimensional iterator returns slices of the current tensor.


\begin{DoxyCode}
\textcolor{keywordtype}{int} main() \{ 

  \hyperlink{classBC_1_1tensors_1_1Tensor__Base}{BC::Cube<float>} cube(3,3,3); 

  \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} matrix : cube.nd\_iter()) \{       
    \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} vec : cube.nd\_iter()) \{        
      \textcolor{keywordflow}{for} (\textcolor{keywordtype}{float}& scalar : vec) \{
         \textcolor{comment}{//do work }
      \}
    \}
  \}
\}
\end{DoxyCode}


{\bfseries Note} Calling {\ttfamily nd\+\_\+iter()} on a Vector forwards to {\ttfamily iter()}. 

 \subparagraph*{Std-\/\+Style Iterators}

Formal {\ttfamily std} style iterators are supported; using {\ttfamily begin} and {\ttfamily end}.


\begin{DoxyCode}
\hyperlink{classBC_1_1tensors_1_1Tensor__Base}{BC::Matrix<float>} mat; 

  mat.\hyperlink{classBC_1_1tensors_1_1Tensor__IterAlgos_a73b44ff31a6c22a172e03f31af4e4d64}{begin}();        
  mat.\hyperlink{classBC_1_1tensors_1_1Tensor__IterAlgos_a5bb5cbc94944c7225db9fd594656f011}{end}();
  mat.\hyperlink{classBC_1_1tensors_1_1Tensor__IterAlgos_a10c1cb1d7095d33b9cc549aa44e98fec}{rbegin}();
  mat.\hyperlink{classBC_1_1tensors_1_1Tensor__IterAlgos_adec36bd5bba166de15c61579fcd5119b}{rend}();

  mat.\hyperlink{classBC_1_1tensors_1_1Tensor__IterAlgos_a791e906b41519aa00b5936c90f6691f9}{nd\_begin}();
  mat.\hyperlink{classBC_1_1tensors_1_1Tensor__IterAlgos_a57c16c64298dc18b878a50048bd2ffee}{nd\_end}();
  mat.\hyperlink{classBC_1_1tensors_1_1Tensor__IterAlgos_a23ce58f5b1563c197ed95719914d4a46}{nd\_rbegin}();
  mat.\hyperlink{classBC_1_1tensors_1_1Tensor__IterAlgos_a8109154106e723b1957c6c22e14ab9b5}{nd\_rend}();
\end{DoxyCode}
 \paragraph*{Utility Iterators}

Convienant iterator proxies which support start and end ranges.


\begin{DoxyCode}
\hyperlink{classBC_1_1tensors_1_1Tensor__Base}{BC::Matrix<float>} mat; 

  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{float}& scalar : mat.\hyperlink{classBC_1_1tensors_1_1Tensor__IterAlgos_a5a6fe492656230dba26f4736215170f5}{iter}(start, finish)) \{
    \textcolor{comment}{//do work}
  \}

  \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} vec : mat.\hyperlink{classBC_1_1tensors_1_1Tensor__IterAlgos_a31a31f7f95cda12e59c24e9c483a1a70}{nd\_iter}(start, finish)) \{
    \textcolor{comment}{//do work}
  \}

  \textcolor{comment}{//reverse iterators are also supported.}
  \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}& \textcolor{keywordtype}{float} : mat.\hyperlink{classBC_1_1tensors_1_1Tensor__IterAlgos_af992794919c12bb33558db90082e9f5a}{reverse\_iter}(finish, start)) \{
    \textcolor{comment}{//do work}
  \}

    \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} vec : mat.reverse\_nd\_iter(finish, start)) \{
    \textcolor{comment}{//do work}
  \}
\end{DoxyCode}
 