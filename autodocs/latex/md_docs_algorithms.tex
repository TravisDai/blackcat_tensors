Black\+Cat\+\_\+\+Tensor\textquotesingle{}s offer a wide range of the standard library\textquotesingle{}s algorithms. These methods are called through the {\ttfamily \hyperlink{namespaceBC}{BC}} namespace.

Black\+Cat\+\_\+\+Tensor\textquotesingle{}s does not implement any of these algorithms itself, instead forwarding to either the std implementation or thrust\textquotesingle{}s implementation depending on how memory is allocated.


\begin{DoxyCode}
\hyperlink{classBC_1_1tensors_1_1Tensor__Base}{BC::Matrix<float, BC::Cuda>} dev\_mat(3,3);
BC::for\_each(dev\_mat.begin(), dev\_mat.end(), your\_function);  \textcolor{comment}{//will call thrust::for\_each}

\hyperlink{classBC_1_1tensors_1_1Tensor__Base}{BC::Matrix<float, BC::Basic\_Allocator>} host\_mat(3,3);
BC::for\_each(dev\_mat.begin(), dev\_mat.end(), your\_function); \textcolor{comment}{//will call std::for\_each}
\end{DoxyCode}


Using B\+C\+::algortihms is preferable to directly using to std or thrust\textquotesingle{}s implementation as it enables user\textquotesingle{}s to write allocation-\/generic code. Here we created a method that applies the logistic function to each element of a matrix.


\begin{DoxyCode}
\textcolor{keyword}{struct }logistic\_functor \{
    \_\_host\_\_ \_\_device\_\_
    \textcolor{keywordtype}{void} operator() (value\_type& scalar) \{
        scalar =  1 / (1 + exp(-scalar));
    \}       

\} logistic; 

\textcolor{keyword}{template}<\textcolor{keyword}{class} alloc>
\textcolor{keywordtype}{void} logistic\_function(\hyperlink{classBC_1_1tensors_1_1Tensor__Base}{BC::Matrix<float, alloc>}& mat) \{
    BC::for\_each(mat.\hyperlink{classBC_1_1tensors_1_1Tensor__IterAlgos_a73b44ff31a6c22a172e03f31af4e4d64}{begin}(), mat.\hyperlink{classBC_1_1tensors_1_1Tensor__IterAlgos_a5bb5cbc94944c7225db9fd594656f011}{end}(), logistic); 
\}
\end{DoxyCode}


This function can accept Tensors allocated on either the G\+PU or C\+PU. If we used std\+::for\+\_\+each, or thrust\+::for\+\_\+each, we would have to write two seperate methods for the host and device.

\subparagraph*{The supported algorithms\+:}

\begin{DoxyVerb}for_each
count
count_if
find
find_if
find_if_not
copy
copy_if
copy_n
fill
fill_n
transform
generate
generate_n
replace
replace_if
replace_copy
replace_copy_if
swap
swap_ranges
reverse
reverse_copy
stable_sort
max_element
min_element
minmax_element
equal\end{DoxyVerb}
 