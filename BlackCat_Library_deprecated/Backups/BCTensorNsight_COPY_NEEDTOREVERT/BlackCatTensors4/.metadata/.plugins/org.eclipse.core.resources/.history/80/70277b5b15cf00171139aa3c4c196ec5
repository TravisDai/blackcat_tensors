/*
 * BC_Tensor_Super_King.h
 *
 *  Created on: Nov 20, 2017
 *      Author: joseph
 */

#ifndef BC_TENSOR_SUPER_KING_H_
#define BC_TENSOR_SUPER_KING_H_

#include "BC_Tensor_Super_Ace.h"

template<class T, class ml, int ... dimensions>
class Tensor_King : Tensor_Ace<T, binary_expression, dimensions...> {

	using functor_type = typename Tensor_Ace<T, binary_expression, dimensions...>::functor_type;

	/*
	 * Tensor_Ace will either generate an array pointer of type T or it will
	 * be of a specialized class for Expression classes
	 */

public:
	template<class U>
	binary_expression<BC::add, ml, functor_type, typename Tensor_King<U, ml, dimensions...>::functor_type, dimensions...> operator +(const Tensor_King<U, ml, dimensions...>& rv) {
		return binary_expression<BC::add, ml, functor_type, typename Tensor_King<U, ml, dimensions...>::functor_type, dimensions...>(this->data(), rv.data());
	}

	template<class U>
	binary_expression<BC::sub, ml, functor_type, typename Tensor_King<U, ml, dimensions...>::functor_type, dimensions...> operator -(const Tensor_King<U, ml, dimensions...>& rv) {
		return binary_expression<BC::sub, ml, functor_type, typename Tensor_King<U, ml, dimensions...>::functor_type, dimensions...>(this->data(), rv.data());
	}

	template<class U>
	binary_expression<BC::mul, ml, functor_type, typename Tensor_King<U, ml, dimensions...>::functor_type, dimensions...> operator %(const Tensor_King<U, ml, dimensions...>& rv) {
		return binary_expression<BC::mul, ml, functor_type, typename Tensor_King<U, ml, dimensions...>::functor_type, dimensions...>(this->data(), rv.data());
	}

	template<class U>
	binary_expression<BC::div, ml, functor_type, typename Tensor_King<U, ml, dimensions...>::functor_type, dimensions...> operator /(const Tensor_King<U, ml, dimensions...>& rv) {
		return binary_expression<BC::div, ml, functor_type, typename Tensor_King<U, ml, dimensions...>::functor_type, dimensions...>(this->data(), rv.data());
	}

};

#endif /* BC_TENSOR_SUPER_KING_H_ */
