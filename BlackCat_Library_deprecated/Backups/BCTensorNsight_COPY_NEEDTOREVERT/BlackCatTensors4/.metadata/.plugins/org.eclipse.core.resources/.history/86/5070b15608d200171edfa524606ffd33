/*
 * BC_Tensor_Super_Queen.h
 *
 *  Created on: Nov 18, 2017
 *      Author: joseph
 */

#ifndef BC_TENSOR_SUPER_QUEEN_H_
#define BC_TENSOR_SUPER_QUEEN_H_

#include "BC_Tensor_Super_King.h"

template<typename T, class ml = CPU, int ... dimensions>
class Tensor_Queen : public Tensor_King<T, ml, dimensions...> {
public:

	Tensor_Queen() {
		ml::initialize(this->array, this->size());
	}

	void fill(T value) {
		ml::fill(this->array, value, this->size());
	}
	void randomize(T lb, T ub) {
		ml::randomize(this->array, lb, ub, this->size());
	}

	template<int curr, int ... dims>
	static void fillArray2(int* ary) {
		ary[0] = curr;

		if (sizeof...(dims) != 0) {
			fillArray2<dims...>(&ary[1]);
		}
	}

	void print() {
		int* ld = new int[sizeof...(dimensions)];
		fillArray2<dimensions...>(ld);
		ml::print(this->array, ld, sizeof(ld), 5);

		delete[] ld;
		//ml::print(this->array, this->size());
	}

	template<class U>
	Tensor_Queen& operator =(const Tensor_King<U, ml, dimensions...>& a) {
		//ml::copy(this->data(), a.data(), this->size());
		return *this;
	}

	template<class o, class lv, class rv>
	inline __attribute__((always_inline)) Tensor_Queen& operator =(binary_expression<o, ml, lv, rv, dimensions...> a) {

		a.eval_to(this->array, this->size());
		return *this;
	}

};
#endif /* BC_TENSOR_SUPER_QUEEN_H_ */
