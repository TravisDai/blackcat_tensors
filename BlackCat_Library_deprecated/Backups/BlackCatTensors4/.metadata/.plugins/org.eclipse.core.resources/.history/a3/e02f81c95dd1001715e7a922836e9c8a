/*
 * BC_Tensor_Super_Queen.h
 *
 *  Created on: Nov 18, 2017
 *      Author: joseph
 */

#ifndef BC_TENSOR_SUPER_QUEEN_H_
#define BC_TENSOR_SUPER_QUEEN_H_

#include "BC_Tensor_Super_King.h"
#include "BC_Expression_Binary_Parser.h"

template<typename T, class ml = CPU, int ... dimensions>
class Tensor_Queen : public Tensor_King<T, ml, dimensions...> {
public:

	Tensor_Queen() {
		ml::initialize(this->array, this->size());
	}

	void fill(T value) {
		ml::fill(this->array, value, this->size());
	}
	void randomize(T lb, T ub) {
		ml::randomize(this->array, lb, ub, this->size());
	}

	void print() {
		ml::print(this->array, this->size());
	}

	template<class U>
	Tensor_Queen& operator =(const Tensor_King<U, ml, dimensions...>& a) {
		//ml::copy(this->data(), a.data(), this->size());
		return *this;
	}

	template<class o, class lv, class rv>
	inline __attribute__((always_inline)) Tensor_Queen& operator =(binary_expression<o, ml, lv, rv, dimensions...> a) {
//		ml::copy(this->data(), a.data(), 1);
//		for (int i = 0; i < this->size(); ++i) {
//			this->array[i] = a[i];
//
//		}
		a.eval_to(this->array, this->size());
		return *this;
	}

};
#endif /* BC_TENSOR_SUPER_QUEEN_H_ */
