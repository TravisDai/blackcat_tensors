/*
 * BC_Expression.h
 *
 *  Created on: Nov 20, 2017
 *      Author: joseph
 */

#ifndef BC_EXPRESSION_BINARY_H_
#define BC_EXPRESSION_BINARY_H_

#include "BC_Tensor_Super_King.h"
#include "BC_Expression_Binary_Parser.h"
#include <functional>


template<class operation, class ml, class lv, class rv, int ... dimensions>
class binary_expression : public Tensor_King<binary_expression<operation, ml, lv, rv, dimensions...>, ml, dimensions...> {
public:
	//, ml, dimensions...

	using this_type = binary_expression<operation,ml, lv, rv, dimensions...>;
	operation oper;

	lv left;
	rv right;

	inline __attribute__((always_inline)) binary_expression(lv l, rv r) :
			left(l), right(r) {
	}

	inline __attribute__((always_inline)) auto operator [](int index) const {
		return oper(left[index], right[index]);
	}

	template<class ary>
	void eval_to(ary a, int sz) {
#pragma omp parallel for

		for (int i = 0; i < sz - 3; i += 2) {
//			oper(a[i], left[i], right[i]);
//			oper(a[i+1],left[i+1], right[i+1]);
			evaluator<operation, lv, rv>;


//			a[i] = left.left[i] + left.right[i] + right[i];
//			a[i + 1] = left.left[i + 1] + left.right[i + 1] + right[i + 1];
		}

		for (int i = sz - 3; i < sz; ++i) {
			a[i] = left[i] + right[i];
		}
#pragma omp barrier
	}

};

#endif /* BC_EXPRESSION_BINARY_H_ */
