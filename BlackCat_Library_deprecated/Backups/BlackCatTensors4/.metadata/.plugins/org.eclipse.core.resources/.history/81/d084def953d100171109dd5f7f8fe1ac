/*
 * BC_Math_ParseBinaryOperations.h
 *
 *  Created on: Nov 23, 2017
 *      Author: joseph
 */

#ifndef BC_EXPRESSION_BINARY_PARSER_H_
#define BC_EXPRESSION_BINARY_PARSER_H_

#include "BC_Expression_Binary.h"
#include <string>
//
//class BinaryExpressionPermutationGenerator {
//
//
//	template<class... params, int... shape>
//	class binary_expression;
//
////	typedef binary_expression be<params, shape> be;
//
//	constexpr std::string operations[] = {
//		"add",
//		"sub",
//		"mul",
//		"div"
//	};
//	constexpr std::string operators[] = {
//			"+",
//			"-",
//			"*",
//			"/"
//	};
//	constexpr std::string template_decleration[] = {
//			"template<class ",
//			", class ml, class, lv, class rv, int... dimensions>"
//	};
//
//	constexpr std::string class_definition[]  = {
//			"class binary_expression<",
//			", ml, lv, rv, dimensions...> : public",
//	};
//
//
//	void gen();
//
//
//	BinaryExpressionPermutationGenerator();
//};

//Forward Declarations
template<class, class, class, class, int...>
class binary_expression;

struct add;
struct sub;
struct div;
struct mul;

template<class >
struct is {
	static constexpr bool expr = false;
};
template<class o, class ml, class lv, class rv, int ... dims>
struct is<binary_expression<o, ml, lv, rv, dims...>> {
	static constexpr bool expr = true;
};

template<class c>
struct expand_binExpr {
	using op = void;
	using ml = void;
	using lv = c;
	using rv = c;
};


template<class oper, class math_lib, class left, class right, int... dimensions>
struct expand_binExpr<expand_binExpr<oper, math_lib, left, right, dimensions...>> {
	using op = oper;
	using ml = math_lib;
	using lv = left;
	using rv = right;
};

template<class oper, class left, class right>
struct evaluator {

	template<class eval_to>
	static auto functor(eval_to to, left l, right r) {

		//If left is expression, typedef lv to functor of type, else typedef lv to left.
		typedef typename std::conditional<is<left>::expr, evaluator<expand_binExpr<left>::op, expand_binExpr<left>::lv, expand_binExpr<left>::rv>::functor, left>::type lv;
		typedef typename std::conditional<is<right>::expr, evaluator<expand_binExpr<right>::op, expand_binExpr<right>::lv, expand_binExpr<right>::rv>::functor, right>::type rv;


		//if both sides are functions
		return is<lv>::expr && is<rv>::expr ? [=](int i) { lv(i, l.left, l.right) + rv(i, r.left, r.right); } :
				//if left is function
				is<lv>::expr ? [=](int i) { l.left + rv[i]; } :
						//if right is a function
						is<rv>::expr ? [=](int i) { lv[i] + rv(i); } :
								//if neither is a function
								[=](int i) {lv[i] + rv[i];};
	}

	static auto functor(left l, right r) {

	}
};

#endif /* BC_EXPRESSION_BINARY_PARSER_H_ */
