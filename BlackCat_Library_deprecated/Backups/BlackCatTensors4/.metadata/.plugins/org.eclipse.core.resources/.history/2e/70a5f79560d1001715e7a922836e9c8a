/*
 * BC_Expression.h
 *
 *  Created on: Nov 20, 2017
 *      Author: joseph
 */

#ifndef BC_EXPRESSION_BINARY_H_
#define BC_EXPRESSION_BINARY_H_

#include "BC_Tensor_Super_King.h"
#include "BC_Expression_Binary_Parser.h"
#include <functional>

template<class operation, class ml, class lv, class rv, int ... dimensions>
class binary_expression : public Tensor_King<binary_expression<operation, ml, lv, rv, dimensions...>, ml, dimensions...> {
public:
	//, ml, dimensions...

	using this_type = binary_expression<operation,ml, lv, rv, dimensions...>;
	operation oper;

	lv left;
	rv right;

	inline __attribute__((always_inline)) binary_expression(lv l, rv r) :
			left(l), right(r) {
	}

	inline __attribute__((always_inline)) auto operator [](int index) const {
		return oper(left[index], right[index]);
	}

	template<class ary>
	inline __attribute__((always_inline)) void eval_to(ary a, int sz) {

		if (sz % 2 == 0) {
#pragma omp parallel for

			for (int i = 0; i < sz; i += 2) {
				a[i] = left.left[i] + left.right[i] + right[i];
				a[i + 1] = left.left[i + 1] + left.right[i + 1] + right[i + 1];
			}
		} else {
#pragma omp parallel for

			for (int i = 0; i < sz - 1; i += 2) {
				a[i] = left.left[i] + left.right[i] + right[i];
				a[i + 1] = left.left[i + 1] + left.right[i + 1] + right[i + 1];
			}
		}

#pragma omp barrier
	}

};




template<class left, class right>
struct evaluator {

		std::function<auto(int, left, right)> functor = [](int i, left l, right r) { return l[i] + r[i]; };


};


#endif /* BC_EXPRESSION_BINARY_H_ */
