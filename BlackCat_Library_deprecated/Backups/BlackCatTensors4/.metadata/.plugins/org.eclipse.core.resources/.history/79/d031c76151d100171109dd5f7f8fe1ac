/*
 * BC_Math_ParseBinaryOperations.h
 *
 *  Created on: Nov 23, 2017
 *      Author: joseph
 */

#ifndef BC_EXPRESSION_BINARY_PARSER_H_
#define BC_EXPRESSION_BINARY_PARSER_H_

#include "BC_Expression_Binary.h"
#include <string>
//
//class BinaryExpressionPermutationGenerator {
//
//
//	template<class... params, int... shape>
//	class binary_expression;
//
////	typedef binary_expression be<params, shape> be;
//
//	constexpr std::string operations[] = {
//		"add",
//		"sub",
//		"mul",
//		"div"
//	};
//	constexpr std::string operators[] = {
//			"+",
//			"-",
//			"*",
//			"/"
//	};
//	constexpr std::string template_decleration[] = {
//			"template<class ",
//			", class ml, class, lv, class rv, int... dimensions>"
//	};
//
//	constexpr std::string class_definition[]  = {
//			"class binary_expression<",
//			", ml, lv, rv, dimensions...> : public",
//	};
//
//
//	void gen();
//
//
//	BinaryExpressionPermutationGenerator();
//};

//Forward Declarations
template<class, class, class, class, int...>
class binary_expression;

struct add;
struct sub;
struct div;
struct mul;

template<class >
struct is {
	static constexpr bool expr = false;
};
template<class o, class ml, class lv, class rv, int ... dims>
struct is<binary_expression<o, ml, lv, rv, dims...>> {
	static constexpr bool expr = true;
};

template<class c>
struct expand_binExpr {
	using op = void;
	using ml = void
	using lv = c;
	using rv = c;
};


template<class oper, class math_lib, class left, class right, int... dimensions>
struct expand_binExpr<expand_binExpr<oper, math_lib, left, right, dimensions...>> {
	using op = oper;
	using ml = math_lib;
	using lv = left;
	using rv = right;
};

template<class oper, class left, class right>
struct evaluator {
	template<class eval_to>
	auto functor(eval_to to, left l, right r) {
		std::conditional<is<left>::expr, expand_binExpr<left>::lv, ,

		, r>::type a;
	}

	auto functor(left l, right r) {

	}
};

#endif /* BC_EXPRESSION_BINARY_PARSER_H_ */
