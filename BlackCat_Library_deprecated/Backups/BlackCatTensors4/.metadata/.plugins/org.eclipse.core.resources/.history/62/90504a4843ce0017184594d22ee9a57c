/*
 * BC_Template_Specialization_States.h
 *
 *  Created on: Nov 20, 2017
 *      Author: joseph
 */

#ifndef BC_TENSOR_SUPER_IDENTITY_IMPL_H_
#define BC_TENSOR_SUPER_IDENTITY_IMPL_H_

#include "BC_Tensor_Super_Identity.h"

struct Vector;
struct Matrix;
struct Cube;
struct Tensor;
struct Scalar;

struct row_Vector;
struct sub_Matrix;
struct sub_Tensor;
struct sub_Cube;

struct indeterminate;

template<int... dims>
struct shape_storage;


//
template<class dimensions, class leading_dimensions = void>
struct Identity {
	//base case -- this causes crash (which is intended)
	using tensor_type = BLACKCAT_indeducible_type;
};

struct Identity<shape_storage<1>> {
	using tensor_type = Scalar;
};

template<int dim>
struct Identity<shape_storage<dim>> {
	using tensor_type = Vector;
};

template<int row, int col>
struct Identity<shape_storage<row, col>> {
	using tensor_type = Matrix;
};

template<int row, int col, int depth>
struct Identity<shape_storage<row, col, depth>> {
	using tensor_type = Cube;
};

template<int... dims>
struct Identity<shape_storage<dims>> {
	using tensor_type = Tensor;
};

//sub types

struct Identity<shape_storage<1>> {
	using tensor_type = Scalar;
};

template<int dim, int ld>
struct Identity<shape_storage<dim>, shape_storage<ld>> {
	using tensor_type = row_Vector;
};

template<int row, int col, int lead_row_height>
struct Identity<shape_storage<row, col>, shape_storage<lead_row_height>> {
	using tensor_type = sub_Matrix;
};

template<int row, int col, int depth, int ld1, int ld2>
struct Identity<shape_storage<row, col, depth>, shape_storage<ld1, ld2>> {
	using tensor_type = sub_Cube;
};

template<int... dims, int... ld_dims>
struct Identity<shape_storage<dims>, shape_storage<ld_dims> {
	using tensor_type = sub_Tensor;
};



#endif /* BC_TENSOR_SUPER_IDENTITY_H_ */
