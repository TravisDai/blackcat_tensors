
///same
template<int movements = 2, class T, class ml, class d1, class d2>
auto x_corr(const TensorBase<d1>& krnl, const TensorBase<d2>& img, std::true_type padded = true) {
	using output_tensor = typename corr_helper::base<movements>::type<T, ml>;
	//initialize dimensionality of the tensor
	_shape dimensions(movements);
	for (int i = 0; i < movements; ++i)
		dimensions[i] = img.dimensions[i] + krnl.dimensions[i] - 1;

	//initialize the output tensor
	output_tensor tensor(dimensions);
	correlation<movements>::x_corr(tensor, krnl, img, std::true_type);
	return tensor;
}
//not same
template<int movements = 2, class T, class ml, class d1, class d2>
auto x_corr(const TensorBase<d1>& krnl, const TensorBase<d2>& img, std::false_type padded = false) {
	using output_tensor = typename corr_helper::base<movements>::type<T, ml>;
	//initialize dimensionality of the tensor
	_shape dimensions(movements);
	for (int i = 0; i < movements; ++i)
		dimensions[i] = img.dimensions[i] - krnl.dimensions[i] + 1;

	//initialize the output tensor
	output_tensor tensor(dimensions);
	correlation<movements>::x_corr(tensor, krnl, img, std::false_type);
	return tensor;

}
// -----------------------------------------------------------the actual implementation ---------------------------------------------------------------------	//

template<int movements>
class correlation {
	namespace corr_helper {
	template<class T, class ml, class d0, class d1, class d2>
	void x_corr(const TensorBase<d0>& out, const TensorBase<d1>& krnl, const TensorBase<d2>& img, std::true_type padded_type = true) {
		//CODE FOR PADDED CORRELATION //
		assert(img.dims() <= movements);

	}
	template<class T, class ml, class d0, class d1, class d2>
	void x_corr(const TensorBase<d0>& out, const TensorBase<d1>& krnl, const TensorBase<d2>& img, std::false_type padded_type = false) {
		//CODE FOR NON PADDED CORRELATION//
		assert(img.dims() <= movements);

		//if movements are greater than krnl rank we "align" the output and krnl
		if (movements > krnl.dims()) {
			for (int i = 0; i < img.dims(); ++i) {
				x_corr(out[i], krnl, img[i], padded_type);
				return;
			}
			//else
			const int IMG_RANK_LAST = img.dims() - 1;
			for (int i = 0; i < img.dimension(IMG_RANK_LAST); ++i) {
				x_corr(out[i], img[i], krnl[i], padded_type);
			}

		}
	}
	} //corr_helper namespace /end
};
template<>  //1d Correlation Specialization (Mandatory)
class correlation<1> {
	namespace corr_helper {
	template<class T, class ml, class d0, class d1, class d2>
	void x_corr(const TensorBase<d0>& out, const TensorBase<d1>& krnl, const TensorBase<d2>& img, std::true_type padded_type = true) {
		//CODE FOR PADDED CORRELATION //
		assert(img.dims() <= movements);
	}
	template<class T, class ml, class d0, class d1, class d2>
	void x_corr(const TensorBase<d0>& out, const TensorBase<d1>& krnl, const TensorBase<d2>& img, std::false_type padded_type = false) {
		//CODE FOR NON PADDED CORRELATION//
		assert(img.dims() <= movements);
		//if movements are greater than krnl rank we "align" the output and krnl
		if (movements > krnl.dims()) {
			for (int i = 0; i < img.dims(); ++i) {
				x_corr(out[i], krnl, img[i], padded_type);
				return;
			}
			//else
			const int IMG_RANK_LAST = img.dims() - 1;
			for (int i = 0; i < img.dimension(IMG_RANK_LAST); ++i) {
				x_corr(out[i], img[i], krnl[i], padded_type);
			}
		}
	}
	} //corr_helper namespace /end
};
//BC namespace /end

//namespace corr_helper {
//template<> struct base<0> { template<class t, class m> using type = Scalar<t,m>;  template<class t, class m> using slice = DISABLED<t, m>; };
//template<> struct base<1> { template<class t, class m> using type = Vector<t, m>; template<class t,class m> using slice = Scalar<t, m>; };
//template<> struct base<2> { template<class t, class m> using type = Matrix<t, m>; template<class t,class m> using slice = Vector<t, m>; };
//template<> struct base<3> { template<class t, class m> using type = Cube<t, m>;   template<class t,class m> using slice = Matrix<t, m>; };
//}
using _shape = std::vector<int>;

///same
template<int movements = 2, class T, class ml, class d1, class d2>
auto x_corr(const TensorBase<d1>& krnl, const TensorBase<d2>& img, std::true_type padded = true) {
	using output_tensor = typename base<movements>::type<T, ml>;
	//initialize dimensionality of the tensor
	_shape dimensions(movements);
	for (int i = 0; i < movements; ++i)
		dimensions[i] = img.dimensions[i] + krnl.dimensions[i] - 1;

	//initialize the output tensor
	output_tensor tensor(dimensions);
	correlation<movements>::x_corr(tensor, krnl, img, std::true_type);
	return tensor;
}
//not same
template<int movements = 2, class T, class ml, class d1, class d2>
auto x_corr(const TensorBase<d1>& krnl, const TensorBase<d2>& img, std::false_type padded = false) {
	using output_tensor = typename base<movements>::type<T, ml>;
	//initialize dimensionality of the tensor
	_shape dimensions(movements);
	for (int i = 0; i < movements; ++i)
		dimensions[i] = img.dimensions[i] - krnl.dimensions[i] + 1;

	//initialize the output tensor
	output_tensor tensor(dimensions);
	correlation<movements>::x_corr(tensor, krnl, img, std::false_type);
	return tensor;

}
// -----------------------------------------------------------the actual implementation ---------------------------------------------------------------------	//

template<int movements, bool same = false>
class correlation {

	template<class T, class ml, class d0, class d1, class d2>
	void x_corr(const TensorBase<d0>& out, const TensorBase<d1>& krnl, const TensorBase<d2>& img) {
		//CODE FOR NON PADDED CORRELATION//
		assert(img.dims() <= movements);

		//if movements are greater than krnl rank we "align" the output and krnl
		if (movements > krnl.dims()) {
			for (int i = 0; i < img.dims(); ++i) {
				x_corr(out[i], krnl[i], img[i]);
				return;
			}
		}
		//move along the axies
		const int positions = img.dimension(img.dims() - 1) - krnl.dimension(img.dims() - 1) + 1;
		for (int i = 0; i < positions; ++i) {
			x_corr<movements - 1>(out[i], img[i], krnl[i]);
		}
		return;
	}
};
template<>  //1d Correlation Specialization (Mandatory)
class correlation<1, false> {
	//if movements are greater than krnl rank we "align" the output and krnl
	template<class T, class ml, class d0, class d1, class d2>
	void x_corr(const TensorBase<d0>& out, const TensorBase<d1>& krnl, const TensorBase<d2>& img) {
		//CODE FOR NON PADDED CORRELATION//
		assert(img.dims() <= movements);

		//if movements are greater than krnl rank we "align" the output and krnl
		if (movements > img.dims()) {
			for (int i = 0; i < img.dims(); ++i) {
				x_corr(out[i], krnl[i], img[i]);
				return;
			}
		}
		//move along the axies
		const int positions = img.dimension(img.dims() - 1) - krnl.dimension(img.dims() - 1) + 1;
		for (int i = 0; i < positions; ++i) {

		}
		return;
	}};
//BC namespace /end