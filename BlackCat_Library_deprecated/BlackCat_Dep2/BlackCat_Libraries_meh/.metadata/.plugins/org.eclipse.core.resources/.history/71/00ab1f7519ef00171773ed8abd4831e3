/*
 * Vector.h
 *
 *  Created on: Dec 30, 2017
 *      Author: joseph
 */

#ifndef VECTOR_H_
#define VECTOR_H_

#include "Tensor_Lv3_Base.h"
#include "Tensor_IdentityClasses.h"
#include "../BC_Shape/Static_Shape.h"

namespace BC {
	template<class T, class shape = Tensor_Shape<Dynamic_Inner_Shape<1>>, class Mathlib = CPU, class isParent = MTF::BOOL<true>>
	class Vector : public Tensor_Base<T, VECTOR, Vector<T, shape, Mathlib, isParent>, Mathlib, shape, isParent>
	{

	using parent_class = Tensor_Base<T, VECTOR, Vector<T, shape, Mathlib, isParent>, Mathlib, shape, isParent>;

	public:

	using parent_class::operator=;

	template<class U>
	Vector<T,shape,Mathlib>& operator = (const Vector<U,shape, Mathlib>& vec) {
			Mathlib::copy(this->data(), vec.data(), this->size());
			return * this;
	}

	Vector<T,shape,Mathlib>& operator = (const Vector<T,shape, Mathlib>& vec) {
			Mathlib::copy(this->data(), vec.data(), this->size());
			return * this;
	}
		template<class... params>
		Vector(const params&... p) : parent_class(p...) {}
		Vector(const Vector<T,shape, Mathlib>& p) : parent_class(p.array) {}
		Vector(int rows) : parent_class({rows}) {}

	void init() {
		Mathlib::initialize(this->array, this->size());
	}
	void del() {
		Mathlib::destroy(this->array);
	}
	void inc() {
		for (int i = 0; i < this->size(); ++i) {
			this->array[i] = i;
		}
	}
}; //Vector

} //End Namespace BC

#endif /* VECTOR_H_ */
