/*
 * Vector.h
 *
 *  Created on: Dec 30, 2017
 *      Author: joseph
 */

#ifndef VECTOR_H_
#define VECTOR_H_

#include "Tensor_Lv2_Core.h"
#include "Tensor_IdentityClasses.h"
#include "../BC_Shape/Static_Shape.h"

namespace BC {
	template<class T, class shape = Tensor_Shape<Dynamic_Inner_Shape<1>>, class Mathlib = CPU, class Parent = MTF::BOOL<true>>
	class Vector : public Tensor_Core<T, VECTOR, Vector<T,shape, Mathlib>, Mathlib>,
	public shape
	{


	using parent_class = Tensor_Core<T, VECTOR, Vector<T,shape, Mathlib>, Mathlib>;

	public:

	using parent_class::operator=;

	template<class U>
	Vector<T,shape,Mathlib>& operator = (const Vector<U,shape, Mathlib>& vec) {
			Mathlib::copy(this->data(), vec.data(), this->size());
			return * this;
	}

	Vector<T,shape,Mathlib>& operator = (const Vector<T,shape, Mathlib>& vec) {
			Mathlib::copy(this->data(), vec.data(), Tensor_Shape<Inner_Shape<5>>::size());
			return * this;
	}
		template<class... params>
		Vector(const params&... p) : parent_class(p...) {}

		Vector(const Vector<T,shape, Mathlib>& p) : parent_class(p.array) {

		}

	void init() {
			Mathlib::initialize(this->array, Tensor_Shape<Inner_Shape<5>>::size());
		}
		void del() {
			Mathlib::destroy(this->array);
		}


		void inc() {
			for (int i = 0; i < Tensor_Shape<Inner_Shape<5>>::size(); ++i) {
				this->array[i] = i;
			}
		}

		void print() const {
			for (int i = 0; i < Tensor_Shape<Inner_Shape<5>>::size(); ++i) {
				std::cout << this->data()[i] << " ";
			}
			std::cout << std::endl;
		}
	};

}

#endif /* VECTOR_H_ */
