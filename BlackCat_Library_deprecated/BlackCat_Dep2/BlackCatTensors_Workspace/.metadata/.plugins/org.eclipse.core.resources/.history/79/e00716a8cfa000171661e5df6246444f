#include "LinearAlgebraRoutines.h"
#include "BLACKCAT_EXPLICIT_INSTANTIATION.h"


template<typename number_type>
void  CPU_MATHEMATICS<number_type>::correlation(number_type* s, const number_type* filter, const number_type* signal, unsigned sz) {
    	number_type tmp = 0;
    	for (unsigned i = 0; i < sz; ++i) {
    		tmp += filter[i] * signal[i];
    	}
    	*s = tmp;
    }

template<typename number_type>
void CPU_MATHEMATICS<number_type>::correlation(number_type* s, unsigned order, const unsigned* ranks,const number_type* filter, const unsigned* f_ld,
																		      const number_type* signal, const unsigned* s_ld) {
	//WORKS
	--order;
	if (order == 0) {
    	number_type tmp = 0;
		correlation(&tmp, filter, signal, ranks[0]);
		*s += tmp;
	} else {

		for (unsigned i = 0; i < ranks[order]; ++i) {
			correlation(s, order, ranks, &filter[i * f_ld[order]], f_ld, &signal[i * s_ld[order]], s_ld);
		}
	}
}



template<typename number_type>
void CPU_MATHEMATICS<number_type>::cross_correlation(number_type* s, unsigned cor_mv, const  unsigned* store_ld,
												const number_type* filter,const  unsigned * f_ld,const  unsigned* f_ranks, unsigned f_order,
												const number_type* signal, const unsigned * s_ld, const unsigned* s_ranks, unsigned s_order) {
	if (cor_mv == 0) {
		correlation(s, f_order, f_ranks, filter, f_ld, signal, s_ld);
	} else {
		--cor_mv;

		unsigned store_id = 0;
		unsigned s_id = 0;

		unsigned mv_positions = s_ranks[cor_mv] + 1;
		mv_positions -= f_order < cor_mv + 1 ? 1 : f_ranks[cor_mv];

		for (unsigned i = 0; i < mv_positions; ++i) {
			cross_correlation(&s[store_id], cor_mv, store_ld, filter, f_ld, f_ranks, f_order, &signal[s_id], s_ld, s_ranks, s_order);

			store_id += store_ld[cor_mv];
			s_id += s_ld[cor_mv];
		}
	}
}

template<typename number_type>
void CPU_MATHEMATICS<number_type>::correlation_filterError(number_type* s, unsigned* store_ld, unsigned* store_ranks, unsigned correlation_dimensionality, number_type* signal, unsigned* s_ld, unsigned* s_ranks, unsigned s_order, number_type* error) {
	--correlation_dimensionality;

	unsigned store_id = 0;
	unsigned s_id = 0;

	for (unsigned i = 0; i < correlation_dimensionality; ++i) {
		correlation_filterError(&s[store_id], cor_mv, store_ld, filter, f_ld, f_ranks, f_order, &signal[s_id], s_ld, s_ranks, s_order);

		store_id += store_ld[cor_mv];
		s_id += s_ld[cor_mv];
	}
}


//template<typename number_type>
//void  CPU_MATHEMATICS<number_type>::correlation_error(number_type* s, const number_type* signal, const number_type* error, unsigned sz) {
//		for (unsigned i = 0; i < sz; ++i) {
//			s[i] = signal[i] * error[0];
//		}
//    }
//
//template<typename number_type>
//void CPU_MATHEMATICS<number_type>::correlation_error(number_type* s, unsigned order, const number_type* error,
//																		   	   	   const number_type* signal, const unsigned* s_ld, const unsigned* s_ranks) {
//	//WORKS
//	--order;
//	if (order == 0) {
//		correlation_error(*s, signal, error, s_ranks[0]);
//	} else {
//
//		for (unsigned i = 0; i < ranks[order]; ++i) {
//			correlation_order(s, order, ranks, &filter[i * f_ld[order]], f_ld, &signal[i * s_ld[order]], s_ld);
//		}
//	}
//}
//

//
//
//static void cross_correlation_noAdjust(number_type* s, unsigned cor_mv, unsigned order, const  unsigned* store_ld, const number_type* filter,const  unsigned * f_ld,const  unsigned* f_ranks,
//																										  const number_type* signal, const unsigned * s_ld, const unsigned* s_ranks);
//
//template<typename number_type>
//void CPU_MATHEMATICS<number_type>::cross_correlation_noAdjust(number_type* s, unsigned cor_mv, unsigned order, const  unsigned* store_ld, const number_type* filter,const  unsigned * f_ld,const  unsigned* f_ranks,
//																										  const number_type* signal, const unsigned * s_ld, const unsigned* s_ranks) {
//	if (cor_mv == 0) {
//		correlation(s, order, f_ranks, filter, f_ld, signal, s_ld);
//	} else {
//		--cor_mv;
//
//		unsigned store_id = 0;
//		unsigned s_id = 0;
//		for (unsigned i = 0; i < s_ranks[cor_mv] - f_ranks[cor_mv] + 1; ++i) {
//			cross_correlation_noAdjust(&s[store_id], cor_mv, order, store_ld, filter, f_ld, f_ranks, &signal[s_id], s_ld, s_ranks);
//
//			store_id += store_ld[cor_mv];
//			s_id += s_ld[cor_mv];
//		}
//	}
//}
