#include "Tensor.h"
#include "BLACKCAT_EXPLICIT_INSTANTIATION.h"

template<typename number_type>
Tensor<number_type>::Tensor() : tensor_ownership(true), rank_ownership(true), ld_ownership(true), subTensor(false) {
	sz = 0;
	order = 0;
	tensor = nullptr;
	dimensions = nullptr;
	leading_dimensions = nullptr;
}

template<typename number_type>
Tensor<number_type>::Tensor(const Tensor<number_type>& cpy) : tensor_ownership(true), rank_ownership(true), ld_ownership(true),subTensor(false) {
	order = cpy.order;
	sz = cpy.sz;

	dimensions = new unsigned[order];
	BC::copy(dimensions, cpy.dimensions, order);

	leading_dimensions = new unsigned[order];
	BC::init_leading_dimensions(leading_dimensions, cpy.dimensions, order);

	Tensor_Operations<number_type>::initialize(tensor, size());

	cpy.subTensor ?
			Tensor_Operations<number_type>::copy(tensor, dimensions, order, leading_dimensions, cpy.tensor, cpy.leading_dimensions)
			:
			Tensor_Operations<number_type>::copy(tensor, cpy.tensor, size());
}

template<typename number_type>
Tensor<number_type>::Tensor(Tensor<number_type> && cpy) : tensor_ownership(true), rank_ownership(true), ld_ownership(true), subTensor(false) {

	order = cpy.order;
	sz = cpy.sz;


	if (cpy.tensor_ownership) {
		tensor = cpy.tensor;
		dimensions = cpy.dimensions;
		leading_dimensions = cpy.leading_dimensions;
		cpy.reset_post_move();

	} else {
		Tensor_Operations<number_type>::initialize(tensor, size());

		dimensions = new unsigned[order];
		BC::copy(dimensions, cpy.dimensions, order);

		leading_dimensions = new unsigned[order];
		BC::init_leading_dimensions(leading_dimensions, cpy.dimensions, order);

		cpy.subTensor ?
				Tensor_Operations<number_type>::copy(tensor, dimensions, order, leading_dimensions, cpy.tensor, cpy.leading_dimensions)
				:
				Tensor_Operations<number_type>::copy(tensor, cpy.tensor, size());
	}
}
template<typename number_type>
Tensor<number_type>::Tensor(const Tensor<number_type>& cpy, bool copy_values) :tensor_ownership(true), rank_ownership(true), ld_ownership(true), subTensor(false) {
	sz = cpy.sz;
	order = cpy.order;

	dimensions = new unsigned[order];
	BC::copy(dimensions, cpy.dimensions, order);

	leading_dimensions = new unsigned[order];
	BC::init_leading_dimensions(leading_dimensions, cpy.dimensions, order);

	Tensor_Operations<number_type>::initialize(tensor, size());
	if (copy_values) {
		cpy.subTensor ?
				Tensor_Operations<number_type>::copy(tensor, dimensions, order, leading_dimensions, cpy.tensor, cpy.leading_dimensions)
				:
				Tensor_Operations<number_type>::copy(tensor, cpy.tensor, size());
	}
}
template<typename number_type>
Tensor<number_type>::Tensor(const Tensor<number_type>& cpy, bool copy_values, bool cpy_trans) : tensor_ownership(true), rank_ownership(true), ld_ownership(true), subTensor(false) {
	sz = cpy.sz;

	order = cpy.order == 1 ? 2 : cpy.order;
	//order = cpy.order;



	dimensions = new unsigned[order];
	leading_dimensions = new unsigned[order];

	BC::copy(dimensions, cpy.dimensions, order);

	if (cpy_trans) {
		if (order > 0)
			dimensions[0] = cpy.cols();
		if (order > 1)
			dimensions[1] = cpy.rows();
	}
	BC::init_leading_dimensions(leading_dimensions, dimensions, order);
	Tensor_Operations<number_type>::initialize(tensor, sz);

	if (copy_values) {
		if (cpy_trans) {
			for (int i = 0; i < totalMatrices(); ++i) {
				unsigned index = i * matrix_size();

				Tensor_Operations<number_type>::transpose(&tensor[index], leading_dimensions[1], &cpy.tensor[index], cpy.rows(), cpy.cols(), cpy.leading_dimensions[1]);
			}
		}
		 else {
			cpy.subTensor ?
							Tensor_Operations<number_type>::copy(tensor, dimensions, order, leading_dimensions, cpy.tensor, leading_dimensions)
							:
							Tensor_Operations<number_type>::copy(tensor, cpy.tensor, size());
		}
	}
}

template<typename number_type>
Tensor<number_type>::Tensor(unsigned m, unsigned n, unsigned k, unsigned p) :
tensor_ownership(true), rank_ownership(true), ld_ownership(true), subTensor(false) {

	order = 4;
	dimensions = new unsigned[order];

	dimensions[0] = m;
	dimensions[1] = n;
	dimensions[2] = k;
	dimensions[3] = p;

	sz = BC::calc_sz(dimensions, order);

	leading_dimensions = new unsigned[order];
	BC::init_leading_dimensions(leading_dimensions, dimensions, order);

	Tensor_Operations<number_type>::initialize(tensor, size());

}

template<typename number_type>
Tensor<number_type>::Tensor(unsigned m, unsigned n, unsigned k) :
tensor_ownership(true), rank_ownership(true), ld_ownership(true), subTensor(false) {
	order = 3;

	dimensions = new unsigned[order];

	dimensions[0] = m;
	dimensions[1] = n;
	dimensions[2] = k;

	leading_dimensions = new unsigned[order];
	BC::init_leading_dimensions(leading_dimensions, dimensions, order);
	sz = m * n * k;
	Tensor_Operations<number_type>::initialize(tensor, size());
}

template<typename number_type>
Tensor<number_type>::Tensor(unsigned m, unsigned n) :
tensor_ownership(true), rank_ownership(true), ld_ownership(true), subTensor(false){
	order = 2;

	dimensions = new unsigned[order];

	dimensions[0] = m;
	dimensions[1] = n;

	sz = m * n;

	leading_dimensions = new unsigned[order];
		BC::init_leading_dimensions(leading_dimensions, dimensions, order);
	Tensor_Operations<number_type>::initialize(tensor, size());
}

template<typename number_type>
Tensor<number_type>::Tensor(unsigned m) :
tensor_ownership(true), rank_ownership(true), ld_ownership(true), subTensor(false) {
	order = 1;

	dimensions = new unsigned[order];

	dimensions[0] = m;
	sz = m;
	leading_dimensions = new unsigned[order];
		BC::init_leading_dimensions(leading_dimensions, dimensions, order);
	Tensor_Operations<number_type>::initialize(tensor, size());
}

template<typename number_type>
Tensor<number_type>::Tensor(std::initializer_list<unsigned> init_ranks) :
tensor_ownership(true), rank_ownership(true), ld_ownership(true), subTensor(false) {

	order = init_ranks.size();
	dimensions = new unsigned[order];

	unsigned ranks_index = 0;
	sz = 1;
	for (auto iter = init_ranks.begin(); iter != init_ranks.end(); ++iter) {
		sz *= *iter;
		dimensions[ranks_index] = *iter;
		++ranks_index;
	}

	leading_dimensions = new unsigned[order];
	BC::init_leading_dimensions(leading_dimensions, dimensions, order);

	Tensor_Operations<number_type>::initialize(tensor, size());
}
typedef std::vector<unsigned> Shape;

template<typename number_type>
Tensor<number_type>::Tensor(const Shape& shape) :
tensor_ownership(true), rank_ownership(true), ld_ownership(true), subTensor(false) {

	order = shape.size();
	dimensions = new unsigned[order];

	sz = 1;
	BC::copy(dimensions, &shape[0], shape.size());
	for (unsigned i = 0; i < shape.size(); ++i) {
		sz *= shape[i];
	}
	leading_dimensions = new unsigned[order];
	BC::init_leading_dimensions(leading_dimensions, dimensions, order);
	Tensor_Operations<number_type>::initialize(tensor, size());

	printDimensions();
	print();
}

template<typename number_type>
std::vector<unsigned> Tensor<number_type>::getShape() const {
	std::vector<unsigned> s = Shape(order);

	for (int i = 0; i < order; ++i) {
		s[i] = dimensions[i];
	}
	return s;
}
template<typename number_type>
Tensor<number_type>::~Tensor() {
	if (tensor_ownership) {
		delete[] tensor;
	}
	if (rank_ownership) {
		delete[] dimensions;
	}
	if (ld_ownership) {
		delete[] leading_dimensions;
	}
	delete self_transposed;
	clearTensorCache();
}

