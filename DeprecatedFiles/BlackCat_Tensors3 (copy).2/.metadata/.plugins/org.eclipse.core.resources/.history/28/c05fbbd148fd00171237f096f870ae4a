/*
 * Matrix.h
 *
 *  Created on: Dec 30, 2017
 *      Author: joseph
 */

#ifndef BC_MATRIX_H
#define BC_MATRIX_H
#include "../BlackCat_Internal_GlobalUnifier.h"
#include "Scalar.h"
#include "Tensor_Base.h"


namespace BC {
template<class T, class Mathlib, class shape>
class Matrix : public Tensor_Base<T, Matrix<T, Mathlib, shape>, Mathlib, shape>
{
	using parent_class = Tensor_Base<T, Matrix<T, Mathlib, shape>, Mathlib, shape>;
	using _int = typename parent_class::subAccess_int;
	using __int = typename parent_class::force_evaluation_int;
	template<class,class, class>
	friend class Vector;

public:
	using parent_class::operator=;
	using parent_class::parent_class;

	Matrix(int rows, int cols = 1) : parent_class({rows, cols}) {}
	Matrix(Matrix<T, Mathlib, shape>&& mat) : parent_class(mat.expression_packet(), at.data()) {}

	template<class U, class shape> Matrix(const Matrix<U, Mathlib, shape>& mat) : parent_class(mat.expression_packet()) { Mathlib::copy(this->data(), mat.data(), this->size()); }
	template<class shape> Matrix(const Matrix<T, Mathlib, shape>& mat) : parent_class(mat.expression_packet()) { Mathlib::copy(this->data(), mat.data(), this->size()); }


	Vector<T, Mathlib, typename shape::ACCESSOR_SHAPE> operator[] (_int i) {
		return (Vector<T, Mathlib, typename shape::ACCESSOR_SHAPE>(&this->array[i]));
	}
	const Vector<T, Mathlib, typename shape::ACCESSOR_SHAPE> operator[] (_int i) const {
		return Vector<T, Mathlib, typename shape::ACCESSOR_SHAPE>(&this->array[i]);
	}

	auto operator [] (__int i) const {
		return this->data()[i];
	}

	Matrix<T, Mathlib, shape>& operator = (const Matrix<T, Mathlib, shape>& mat) {
		this->assert_same_size(mat);
		Mathlib::copy(this->data(), mat.data(), this->size());
		return this->asBase();
	}
	template<class U, class S>
	Matrix<T, Mathlib, shape>& operator = (const Matrix<U, Mathlib, S>& mat) {
		this->assert_same_size(mat);
		Mathlib::copy(this->data(), mat.data(), this->size());
		return this->asBase();
	}

};

} //End Namespace BC

#endif /* VECTOR_H_ */
