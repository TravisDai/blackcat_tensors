/*
 * BC_MetaTemplate_EssentialMethods.h
 *
 *  Created on: Dec 11, 2017
 *      Author: joseph
 */

#ifndef ADHOC_H_
#define ADHOC_H_

#include "../BlackCat_Internal_GlobalUnifier.h"

#include "Simple.h"
namespace BC {
	namespace MTF {


		template<class, int, int, class...> class Matrix;
		template<class, int, class...> class Vector;


		//class variant of bool (good when you only want to use classes as templates)
		template<bool value>
		struct BOOL {
				static constexpr bool conditional = value;
		};

		template<class...>
		struct _list;

		template<class, class>  struct expression_substitution;

		template<class sub, template<class, class, bool> class derived, class scalar_type, class ml, bool parent>
		struct expression_substitution<sub, derived<scalar_type, ml , parent>>{
			static constexpr bool parent_status = MTF::isPrimitive<scalar_type>::conditional && parent;
				using type = derived<sub, ml, parent_status>;
		};

//		//Vector Specialization
//		template<class, class>  struct expression_substitution;
//		template<class sub, template<class, int, class...> class derived, class scalar_type, class... modifiers, int rows>
//		struct expression_substitution<sub, derived<scalar_type, rows, modifiers...>>{
//				using type = derived<sub, rows, modifiers...>;
//		};
//		//Matrix Specialization
//		template<class, class>  struct expression_substitution;
//		template<class sub, template<class, int, int, class...> class derived, class scalar_type, class... modifiers, int rows, int cols>
//		struct expression_substitution<sub, derived<scalar_type, rows, cols, modifiers...>>{
//				using type = derived<sub, rows, cols, modifiers...>;
//		};

		template<class T>
		struct determine_scalar {
				using type = T;
		};
		template<template<class...> class tensor, class T, class... set>
		struct determine_scalar<tensor<T, set...>> {
				using type = typename determine_scalar<T>::type;
		};


		template<class T, class voider = void>
		struct determine_functor {
				using type = T;
		};

		template<class>struct isPrimitive;

		template<class T>
		struct determine_functor<T, typename std::enable_if<MTF::isPrimitive<T>::conditional, void>::type> {
				using type = T*;
		};

		template<class tensor>
		struct determine_evaluation;

		template<bool, class T> struct if_AddRef { using type = T; };
		template<	   class T> struct if_AddRef<true> { using type = T&; };

		template<template<class, class, bool> class tensor, class T, class ML, bool parent>
		struct determine_evaluation<tensor<T, ML, parent>> {

			using scalar_type = typename determine_scalar<T>::type;
			static constexpr bool parent_status = MTF::same<T, scalar_type>::conditional && parent;
			using type_ = tensor<scalar_type, ML, parent_status>;
			using type  = typename if_AddRef<MTF::same<tensor<T, ML, parent>, type_>::conditional, type_>::type;
		};

//		///Scalar
//		template<template<class, class...> class scalar, class T, class... traits>
//		struct determine_evaluation<scalar<T, traits...>> {
//				using scalar_type = typename determine_scalar<T>::type;
//				using type = scalar<scalar_type, traits...>;
//		};
//		///Vector
//		template<template<class, int, class...> class vector, class T, int rows, class... traits>
//		struct determine_evaluation<vector<T, rows, traits...>> {
//				using scalar_type = typename determine_scalar<T>::type;
//				using type = vector<scalar_type, rows, traits...>;
//		};
//		///Matrix
//		template<template<class, int, int, class...> class matrix, class T, int rows, int cols, class... traits>
//		struct determine_evaluation<matrix<T, rows, cols, traits...>> {
//				using scalar_type = typename determine_scalar<T>::type;
//				using type = matrix<scalar_type, rows, cols, traits...>;
//		};

	}
}
#endif /* ADHOC_H_ */
