/*
 * Vector.h
 *
 *  Created on: Dec 30, 2017
 *      Author: joseph
 */

#ifndef Matrix_H
#define Matrix_H

#include "Vector.h"
#include "Tensor_Base.h"


namespace BC {
template<class T, class Mathlib, bool Parent>
class Matrix : public Tensor_Base<T, Matrix<T, Mathlib, Parent>, Mathlib, Parent, 2>
{
	using this_class = Matrix<T, rows, cols, Mathlib, LD>;
	using parent_class = Tensor_Base<T, Matrix<T, Mathlib, Parent>, Mathlib, Parent, 2>;
	using _int = typename parent_class::subAccess_int;
	using __int = typename parent_class::force_evaluation_int;
	template<class, int, int, class, class> friend class Matrix;

public:

	using parent_class::operator=;
	using parent_class::parent_class;

	Matrix<T, rows, cols, Mathlib, LD>& operator = (const Matrix<T, rows, cols, Mathlib, LD>& mat)  {
		this->assert_same_size(mat);
		Mathlib::copy(this->data(), mat.data(), this->size());
		return this->asBase();
	}
	auto operator [] (__int i) const {
		return this->data()[i];
	}
		  Vector<T, rows, Mathlib, LD> operator[] (_int i) {
		return Vector<T, rows, Mathlib, LD>(&this->array[i * this->rows()]);
	}
	const Vector<T, rows, Mathlib, LD> operator[] (_int i) const {
		return Vector<T, rows, Mathlib, LD>(&this->array[i * this->rows()]);
	}

	const Matrix<unary_expression_transpose_mat<T, this_class>, cols, rows, Mathlib, LD> t() const {
		return Matrix<unary_expression_transpose_mat<T, this_class>, cols, rows, Mathlib, LD>(*this, this->data());
	}
		  Matrix<unary_expression_transpose_mat<T, this_class>, cols, rows, Mathlib, LD> t() {
		return Matrix<unary_expression_transpose_mat<T, this_class>, cols, rows, Mathlib, LD>(*this, this->data());
	}
};

} //End Namespace BC


#endif /* Matrix */
